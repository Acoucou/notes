{"./":{"url":"./","title":"目录","keywords":"","body":" 目录 Author: cpu_code Gitee: https://gitee.com/cpu_code Github: https://github.com/CPU-Code CSDN: https://blog.csdn.net/qq_44226094 gitbook: https://923992029.gitbook.io/cpucode/ 介绍 个人学习笔记 , 涵盖C , C++, Linux驱动, Linux内核, 嵌入式, 数据结构, 算法, QT, Android安卓, 音视频, 物联网 , 正在逐步更新 , 使用的typora编辑 , 大家可以使用 typora 打开查看 , 床图为 gitee Linux驱动开发 字符设备驱动开发 Linux驱动开发 安卓底层开发 硬件抽象层 智能指针 AOSP源码开发 Android底层软硬件结合开发概述 操作系统 操作系统的运行机制 进程 linux一句话 与网络无关的Linux Linux内核0.12 微型计算机组成结构 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-13 22:51:30 "},"linux_driver/character_device_driver.html":{"url":"linux_driver/character_device_driver.html","title":"字符设备驱动开发","keywords":"","body":" 字符设备驱动开发 @Author: cpu_code @Date: 2020-07-12 14:09:20 @LastEditTime: 2020-07-12 21:08:35 @FilePath: \\note\\android_bottom\\smart_pointer.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ 字符设备驱动简介 字符设备是 Linux 驱动中最基本的设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、 IIC、 SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:09:16 "},"linux_driver/linux_driver.html":{"url":"linux_driver/linux_driver.html","title":"Linux驱动开发","keywords":"","body":" Linux驱动开发 @Author: cpu_code @Date: 2020-07-11 16:10:23 @LastEditTime: 2020-07-12 21:08:01 @FilePath: \\note\\linux_driver\\linux_driver.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ 文件目录 : 粉丝不够W Linux设备驱动开发详解( 宋宝华 )笔记 Linux设备驱动概述及开发环境构建 设备驱动的作用 设备驱动提供了硬件和应用软件之间的纽带 应用软件时只需 调用系统软件的应用编程接口（API） 就可让硬件去完成要求的工作 无操作系统时的设备驱动 不是任何一个计算机系统都一定要有操作系统 循环 对设备中断的检测 或 对设备的轮询 //单任务软件架构 int main(int argc, char* argv[]) { while(1) { /*有串口中断*/ if(serialInt == 1) { ProcessSerialInt(); /* 处理串口中断 */ serialInt = 0; /* 中断标志变量清0 */ } /* 有按键中断 */ if(keyInt == 1) { ProcessKeyInt(); /* 处理按键中断 */ keyInt = 0; /* 中断标志变量清0 */ } status = CheckXXX(); switch (status) { //... } //... } } //无操作系统情况下串口的驱动 /********************** * serial.h **********************/ extern void SerialInit(void); extern void SerialSend(const char buf*, int count); extern void SerialRecv(char buf*, int count); ​ /********************** * serial.c文件 **********************/ ​ /* 初始化串口 */ void SerialInit(void) { //... } ​ /* 串口发送 */ void SerialSend(const char *buf, int count) { //... } ​ /* 串口接收 */ void SerialRecv(char *buf, int count) { //... } ​ /* 串口中断处理函数 */ void SerialIsr(void) { //... serialInt = 1; } 无操作系统时硬件、 设备驱动和应用软件的关系 : 驱动与应用高耦合的不合理设计 : 应用直接访问硬件的不合理设计: 有操作系统时的设备驱动 操作系统 把单一的“ 驱使硬件设备行动 ”变成了操作系统内与硬件交互的模块， 设为操作系统的API， 给应用程序提供接口 硬件、驱动、操作系统和应用程序的关系 : 操作系统给我们提供内存管理机制 : MMU的32位处理器 , 可以让 每个进程都可以独立地访问 4GB 的内存空间 应用程序将可使用统一的系统调用接口来访问各种设备 Linux设备驱动 设备的分类及特点 计算机系统的硬件主要由 CPU、 存储器 和 外设组成 一般的处理器都集成了UART、I2C控制器、 SPI控制器、 USB控制器、 SDRAM控制器等， 有的处理器还集成了GPU（图形处理器） 、 视频编解码器 Linux将 存储器 和 外设 分为3个基础大类 : 字符设备 : 以串行顺序依次进行访问的设备， 如触摸屏、 磁带驱动器、 鼠标等。 块设备 : 按任意顺序进行访问， 以块为单位进行操作，如硬盘、 eMMC等 使用文件系统的操作接口 open() 、 close() 、read() 、 write() 等进行访问 网络设备 : 面向数据包的 接收 和 发送 , 使用套接字接口 Linux设备驱动与整个软硬件系统的关系 字符设备 与 块设备都 被映射到 Linux文件系统的文件和目录， 通过文件系统的系统调用接口 open() 、 write() 、read()、 close() 等 即可访问 字符设备 和 块设备 Linux的块设备有两种访问方法 : 类似 dd命令对应的原始块设备， 如“ /dev/sdb1 ”等 块设备上建立FAT、EXT4、 BTRFS等文件系统， 然后以文件路径 , 如“ /home/barry/hello.txt ”的形式进行访问 在Linux中， 对 NOR、 NAND 等提供了独立的内存技术设备（Memory Technology Device， MTD） 子系统， 可以运行YAFFS2、 JFFS2、UBIFS等具备 擦除 和 负载均衡 能力的文件系统。 Linux设备驱动与整个软硬件系统的关系 : C库函数是通过系统调用接口而实现， 如C库函数 fopen() 、 fwrite() 、 fread() 、 fclose() 分别会调用操作系统的API open() 、 write() 、 read() 、 close() 为了代码可移植性的目的 , 应用程序最好使用C库函数 Linux设备驱动的重点、 难点 懂得SRAM、Flash、 SDRAM、 磁盘的读写方式， UART、 I2C、 USB等设备的接口以及轮询、 中断、 DMA的原理， PCI总线工作方式以及CPU的内存管理单元（MMU） 运用C语言的结构体、 指针、 函数指针及内存动态申请和释放等 有一定的Linux内核基础，至少要明白驱动与内核的接口。 尤其是对于块设备、 网络设备、 Flash设备、 串口设备等复杂设备 有 多任务并发控制 和 同步 的基础， 因为在驱动中有大量的自旋锁、 互斥、 信号量、 等待队列等 并发与同步机制 Linux设备驱动的开发环境构建 PC上的Linux环境 QEMU实验平台 源代码阅读和编辑 http://lxr.free-electrons.com、 http://lxr.oss.org.cn/ , 这样的网站提供了Linux内核源代码的交叉索引 Linux主机上阅读和编辑Linux源码的常用方式是 vim + cscope或者 vim+ ctags， vim 是一个文本编辑器， 而 cscope 和 ctags 则可建立代码索引 vscode使用 设备驱动Hello World： LED驱动 无操作系统时的LED驱动 GPIO一般由 两组寄存器控制， 一组控制寄存器 和 一组数据寄存器 控制寄存器可设置 GPIO 口的工作方式为 输入 或 输出 。 当引脚被设置为输出时， 向 数据寄存器 的对应位写入 1 和 0 会分别在引脚上产生 高电平和 低电平 当引脚设置为输入时， 读取 数据寄存器 的对应位可获得引脚上的电平为 高 或 低 如： 在　GPIO_REG_CTRL　物理地址中控制寄存器处的第 n 位写入 1 可设置 GPIO 口为输出， 在地址 GPIO_REG_DATA 物理地址中数据寄存器的第 n 位写入1 或 0 可在引脚上产生 高 或 低电平． //无操作系统时的LED驱动 //启动硬件MMU后，将寄存器的 物理地址 转化为 虚拟地址 #define reg_gpio_ctrl *(volatile int *)(ToVirtual(GPIO_REG_CTRL)) #define reg_gpio_data *(volatile int *)(ToVirtual(GPIO_REG_DATA)) ​ /* 初始化LED */ void LightInit(void) { reg_gpio_ctrl |= (1 Linux下的LED驱动 内核中实际实现了一个提供sysfs节点的GPIO LED驱动， 位于 drivers/leds/leds-gpio.c 中 #include //.../* 包含内核中的多个头文件 */ ​ /* 设备结构体 */ struct light_dev { struct cdev cdev; /* 字符设备cdev结构体 */ unsigned char vaule; /* LED亮时为1， 熄灭时为0， 用户可读写此值 */ }; ​ struct light_dev *light_devp; int light_major = LIGHT_MAJOR; /* 打开和关闭函数 */ int light_open(struct inode *inode, struct file *filp) { struct light_dev *dev; /* 获得设备结构体指针 */ dev = container_of(inode->i_cdev, struct light_dev, cdev); /* 让设备结构体作为设备的私有信息 */ filp->private_data = dev; return 0; } ​ int light_release(struct inode *inode, struct file *filp) { return 0; } ​ /* 读写设备:可以不需要 */ ssize_t light_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { struct light_dev *dev = filp->private_data; /* 获得设备结构体 */ if(copy_to_user(buf, &(dev->value), 1)) { return -EFAULT; } return 1; } ​ ssize_t light_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) { struct light_dev *dev = filp->private_data; if(copy_from_user(&(dev->value), buf, 1)) { return -EFAULT; } /* 根据写入的值点亮和熄灭LED */ if(dev->value == 1) { light_on(); } else { light_off() } return 1; } ​ /* ioctl函数 */ int light_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct light_dev *dev = filp->private_data; switch(cmd) { case LIGHT_ON: dev->value = 1; light_on(); break; case LIGHT_OFF: dev->value = 0; light_off(); break; ​ default: /* 不能支持的命令 */ return -ENOTTY; } return 0; } ​ struct file_operations light_fops = { .owner = THIS_MODULE, .read = light_read, .write = light_write, .unlocked_ioct1 = light_ioctl, .open = light_open, .release = light_release, }; ​ /* 设置字符设备cdev结构体 */ static void light_setup_cdev(struct light_dev *dev, int index) { int err; int devno = MKDEV(light_major, index); cdev_init(&dev->cdev, &light_fops); dev->cdev.owner = THIS_MODULE; dev->cdev.ops = &light_fops; err = cdev_add(&dev->cdev, devno, 1); if(err) { printk(KERN_NOTICE \"Error %d adding LED%d\", err, index); } } ​ /* 模块加载函数 */ int light_init(void) { int result; dev_t dev = MKDEV(light_major, 0); /* 申请字符设备号 */ if(light_major) { //字符设备注册 result = register_chrdev_region(dev, 1, \"LED\"); } else { // 分配 result = alloc_chrdev_region(&dev, 0, 1, \"LED\"); light_major = MAJOR(dev); } if((result cdev); /* 释放在light_init中分配的内存 */ kfree(light_devp); /* 删除字符设备 */ unregister_chrdev_region(MKDEV(light_major, 0), 1); } ​ MODULE_AUTHOR(\"cpucode\"); MODULE_LICENSE(\"GPL\"); 驱动设计的硬件基础 处理器 通用处理器 很多的通用处理器（GPP） 采用SoC（片上系统） 的芯片设计方法， 集成了各种功能模块， 每一种功能都是由硬件描述语言设计程序，然后在SoC内由电路实现的 ARM SoC范例： Snapdragon 810 : ARM移动处理芯片供应商包括 高通（Qualcomm） 、 三星（Samsung） 、 英伟达（Nvidia） 、 美满（Marvell） 、 联发科（MTK） 、 海思（HiSilicon） 、 展讯（Spreadtrum） 等 中央处理器的体系结构可以分为两类 : 冯·诺依曼结构( 普林斯顿结构 )，将程序指令存储器和数据存储器合并在一起的存储器结构 , 程序指令和数据的宽度相同。 如 : Intel公司的中央处理器 哈佛结构 , 将 程序指令 和 数据 分开存储， 指令和数据是不同的数据宽度 如 : Cortex A系列 哈佛结构还采用了独立的程序总线和数据总线， 分别为CPU 与 每个存储器之间的专用通信路径， 提高了执行效率 冯· 诺依曼结构 与 哈佛结构 : 改进的哈佛架构， 有独立的地址总线和数据总线 , 两条总线由 程序存储器 和 数据存储器 分时共用 改进的哈佛结构对 程序 和 数据， 使用公用数据总线来完成 程序存储模块 或 数据存储模块 与 CPU 之间的数据传输， 公用的地址总线来寻址 程序 和 数据 改进的哈佛结构 : 指令集的角度来讲， 中央处理器也可以分为两类 : RISC（精简指令集计算机） 和CISC（复杂指令集计算机） CSIC 强调增强指令的能力、 减少目标代码的数量， 但 指令复杂， 指令周期长； 而RISC强调尽量减少指令集、 指令单周期执行， 但 目标代码会更大 数字信号处理器 数字信号处理器（DSP） 针对通信、 图像、 语音和视频处理等领域的算法而设计 DSP分为两类， 定点DSP， 浮点DSP。 浮点DSP的浮点运算用硬件来实现， 可以在单周期内完成， 因此浮点运算处理速度高于定点DSP。 而定点DSP只能用定点运算模拟浮点运算 网络处理器器件内部通常由 n个微码处理器 和 n个硬件协处理器 组成， 多个微码处理器在网络处理器内部并行处理， 通过预先编制的微码来控制处理流程 处理器分类 : 处理器按应用领域分类融合,数字信号控制器_DSC_通用处理器_GPP_微控制器_MCU_简称单片机微处理器__MPU数字信号处理器_DSP_定点DSP浮点DSP专门处理器_ASO_及ASIC网络处理器音视频编解码器按体系结构分类冯诺依曼结构哈佛结构按指令集分类RISCCSIC MCU 处理图形用户界面和用户的按键输入并运行多任务操作系统 DSP进行音视频编解码 射频方面则采用ASIC 存储器 存储器主要可分类为只读储存器（ROM） 、 闪存（Flash） 、 随机存取存储器（RAM） 、 光/磁介质储存器。 ROM可细分为 不可编程ROM、 可编程ROM（PROM） 、 可擦除可编程ROM（EPROM） 和电可擦除可编程ROM（E2PROM） ， E2PROM完全可以用软件来擦写 Flash闪存技术两种主要的是 NOR（或非） 和 NAND（与非） NOR Flash的特点是可芯片内执行（eXecute InPlace， XIP） ， 程序可以直接在NOR内运行 NAND Flash以 块方式进行访问， 不支持芯片内执行 典型的类SRAM接口 : 公共闪存接口（Common Flash Interface， CFI） 是一个从NOR Flash器件中读取数据的公开、 标准接口 如 芯片不支持CFI， 可使用JEDEC（Joint Electron Device EngineeringCouncil， 电子电器设备联合会）, 需要读出 制造商ID 和 设ID， 来获取 Flash的大小 NAND Flash的主要接口 I/O总线： 地址、 指令 和 数据通过这组总线传输， 一般为8位或16位 芯片启动（Chip Enable， CE#） ： 如果没有检测到CE信号， NAND器件就保持待机模式， 不对任何控制信号做出响应 写使能（Write Enable， WE#） ： WE#负责将数据、 地址或指令写入NAND之中 读使能（Read Enable， RE#） ： RE#允许数据输出 指令锁存使能（Command Latch Enable， CLE） ： 当CLE为高电平时，在WE#信号的上升沿， 指令将被锁存到NAND指令寄存器中 地址锁存使能（Address Latch Enable， ALE） ： 当ALE为高电平时， 在WE#信号的上升沿， 地址将被锁存到NAND地址寄存器中。 就绪/忙（Ready/Busy， R/B#） ： 如果NAND器件忙， R/B#信号将变为低电平。 该信号是漏极开路， 需要采用上拉电阻 使用NAND Flash的同时， 应采用 错误探测 / 错误更正（EDC / ECC） 算法 Flash的编程原理都是 只能将1写为0， 而 不能将0写为1 RAM可分为静态RAM（SRAM） 和 动态RAM（DRAM） DRAM以电荷形式进行存储， 数据存储在电容器中 , 需要定期刷新 SRAM是静态的， 只要供电它就会保持一个值， SRAM没有刷新周期 DPRAM： 双端口RAM DPRAM的优点是通信速度快、 实时性强、 接口简单， 而且两边处理器都可主动进行数据传输 双端口RAM : CAM： 内容寻址RAM CAM是以内容进行寻址的存储器 , 输入要查询的数据， 输出就是 数据地址 和 匹配标志。 若匹配（即搜寻到数据） ， 则输出数据地址。 CAM的输入与输出 : FIFO： 先进先出队列 FIFO存储器的特点是先进先出， 进出有序， FIFO多用于数据缓冲 . 存储器分类 : 存储器非易失性存储器_NVM_ROM_ROM_PROMEPROME2PROMFlashNORFlashNANDFlash光/磁介质存储器掉电丢失数据的RAMSRAMDRAM_SDRM_DDR_SDRAM_特定类型的RAM一般采用SRAMNVRAMDPRAMCAMFIFO 接口与总线 串口 RS-232、 RS-422 与 RS-485 都是串行数据接口标准 RS-232 : 命名为 EIA-232-E RS-422 : 定义了一种平衡通信接口， 它是一种单机发送、 多机接收的单向、 平衡传输规范， 被命名为 TIA/EIA-422-A 标准 RS-485 : 增加了多点、 双向通信能力， 允许多个发送器连接到同一条总线上，同时增加了 发送器的驱动能力 和 冲突保护特性， 并扩展了 总线共模范围， 被命名为TIA/EIA-485-A标准。 RS-232C : 为连接 DTE（数据终端设备） 与 DCE（数据通信设备） 而制定 . RS-232C标准接口有25条线（4条数据线、 11条控制线、 3条定时线、 7条备用和未定义线）, 常用的只有9根， 它们是RTS/CTS（请求发送/清除发送流控制） 、RxD/TxD（数据收发） 、 DSR/DTR（数据设置就绪/数据终端就绪流控制） 、DCD（数据载波检测， 也称RLSD， 即接收线信号检出） 、 Ringing-RI（振铃指示） 、 SG（信号地） 信号。 RTS： 用来表示 DTE请求DCE发送数据， 当终端要发送数据时， 使该信号有效 CTS： 用来表示DCE准备好接收DTE发来的数据， 是对RTS的响应信号。 RxD： DTE通过RxD接收从DCE发来的串行数据。 TxD： DTE通过TxD将串行数据发送到DCE。 DSR： 有效（ON状态） 表明DCE可以使用。 DTR： 有效（ON状态） 表明DTE可以使用。 DCD： 当本地DCE设备收到对方DCE设备送来的载波信号时， 使DCD有效， 通知DTE准备接收， 并且由DCE将接收到的载波信号解调为数字信号， 经RxD线送给DTE。 Ringing-RI： 当调制解调器收到交换台送来的振铃呼叫信号时， 使该信号有效（ON状态） ， 通知终端， 已被呼叫。 RS-232C串口电路原理 : I2C I2C（ 内置集成电路） 总线是由Philips公司开发的两线式串行总线 I2C总线支持多主控（ Multi-Mastering） 模式， 任何能够进行发送和接收的设备都可以成为主设备。 两个信号为数据线SDA和时钟SCL 总线的输出端必须是开漏输出( CMOS )或 集电极开路( TTL )输出的结构。 总线空闲时， 上拉电阻使 SDA 和 SCL线都保持高电平。 根据 开漏输出 或 集电极开路输出信号的“ 线与 ”逻辑， I2C总线上任意器件输出 低电平 都会使相应总线上的信号线变低 当 SCL稳定在高电平时， SDA 由高到低 的变化将产生一个开始位， 而 由低到高 的变化则产生一个停止位 I2C总线的开始位和停止位 : 开始位 和 停止位 都由I2C主设备产生。 在选择从设备时， 如果从设备采用7位地址， 则主设备在发起传输过程前， 需先发送1字节的地址信息， 前7位为设备地址， 最后1位为读写标志。 数据传输， 每次传输的数据也是1字节， 从MSB开始传输。 每个字节传完后， 在SCL的第9个上升沿到来之前， 接收方应该发出1个ACK位。 I2C总线的时序 : SPI SPI（ Serial Peripheral Interface， 串行外设接口） 总线系统是一种同步串行外设接口 , 使CPU与各种外围设备以串行方式进行通信以交换信息。一般主控SoC作为SPI的“ 主 ”， 而外设作为SPI的“ 从 ” SPI接口一般使用4条线： 串行时钟线（ SCLK） 、 主机输入/从机输出数据线 MISO、 主机输出/从机输入数据线 MOSI 和 低电平有效的从机选择线SS SPI主、 从硬件连接图 : 在SPI总线的传输中， SS信号是低电平有效的， 当我们要与某外设通信的时候， 需要将该外设上的SS线置低。 SPI从设备支持的SPI总线最高时钟频率（ 决定了SCK的频率） 决定了数据与时钟之间的偏移 , 外设的CPHA决定了采样的时刻、CPOL模式决定了触发的边沿是上升沿还是下降沿 SPI模块为了和外设进行数据交换， 根据外设工作要求， 其输出串行同步时钟极性（CPOL） 和相位（CPHA） 可以进行配置。 如 CPOL = 0， 串行同步时钟的空闲状态 = 低电平； 如 CPOL = 1， 串行同步时钟的空闲状态 = 高电平。 如 CPHA = 0， 在串行同步时钟的第一个跳变沿（上升或下降） 数据被采样； 如 CPHA = 1， 在串行同步时钟的第二个跳变沿（上升或下降） 数据被采样 SPI总线的时序 : USB USB（ 通用串行总线） 具有数据传输率高、 易扩展、 支持即插即用 和 热插拔的优点 USB 1.1包含全速和低速两种模式， 低速模式的速率为1.5Mbit/s， 支持小数据吞吐量 和 高实时性的设备， 如鼠标等。 全速模式为12Mbit/s， 可以外接速率更高的外设。 在USB 2.0中， 增加了一种高速方式，数据传输率达到480Mbit/s， 半双工， 满足更高速外设的需要。 采用4芯的屏蔽线， 一对差分线（ D+、 D-） 传送信号， 另一对（ VBUS、 电源地） 传送+5V的直流电 . 增添的 Bulk模式支持1个数据流 而USB3.0（ 也被认为是Super Speed USB） 的最大传输带宽高达5.0Gbit/s（ 即640MB/s） ， 全双工。 设计了8条内部线路， 除VBUS、 电源地之外， 其余3对均为 数据传输线路。 其中保留了 D+ 与 D- 这两条兼容USB 2.0的线路， 新增了SSRX与SSTX专为USB 3.0所设的线路 . 增加了 Bulk Streams传输模式 支持多个数据流， 每个数据流被分配一个Stream ID（SID） ， 每个SID与一个主机缓冲区对应 . 开发板需要挂接USB设备， 则需提供USB主机（ Host） 控制器和连接器； 作为USB设备， 则需提供USB设备适配器和连接器 USB的物理拓扑结构 : 每一个USB设备会有一个或者多个逻辑连接点在里面， 每个连接点叫端点 以下是端点传输方式 : 控制（Control） 传输方式 控制传输是双向传输， 数据量通常较小， 主要用来进行查询、 配置和给USB设备发送通用命令。 所有USB设备必须支持标准请求（StandardRequest） ， 控制传输方式 和 端点0。 同步（Isochronous） 传输方式 ( Streaming Real-time ) 同步传输提供了确定的带宽和间隔时间， 它用于时间要求严格并具有较强容错性的流数据传输， 或 用于要求恒定数据传送率的即时应用 . 如: 语音业务传输 中断（Interrupt） 传输方式 中断方式传送是单向的， 对于USB主机而言， 只有输入。 中断传输方式主要用于定时查询设备是否有中断数据要传送， 该传输方式应用在少量分散的、 不可预测的数据传输场合， 如: 键盘、 游戏杆和 鼠标 批量（Bulk） 传输方式 批量传输主要应用在没有带宽、 间隔时间要求的批量数据的传送和接收中， 它要求保证传输。 如 : 打印机和扫描仪 集线器负责检测设备的连接和断开， 利用其中断IN端点（Interrupt IN Endpoint） 来向主机报告。 一旦获悉有新设备连接上来， 主机就会发送一系列请求给设备所挂载的集线器， 再由集线器建立起一条连接主机和设备之间的通信通道。 然后主机以控制传输的方式， 通过端点0对设备发送各种请求， 设备收到主机发来的请求后回复相应的信息， 进行枚举（Enumerate） 操作。 因此USB总线具备热插拔的能力 以太网接口 以太网接口由MAC（以太网媒体接入控制器） 和 PHY（物理接口收发器） 组成 以太网MAC由 IEEE 802.3 以太网标准定义， 实现了数据链路层 MAC 和 PHY之间采用 MII（媒体独立接口） 连接， 它是 IEEE-802.3定义的以太网行业标准， 包括 1个数据接口 与 MAC 和 PHY 之间的1个管理接口 数据接口包括分别用于 发送 和 接收 的两条独立信道， 每条信道都有自己的 数据、时钟 和 控制信号， MII数据接口总共需要16个信号。 MII管理接口有两个信号， 时钟信号， 数据信号。 通过管理接口， 上层能 监视 和 控制PHY 以太网接口的硬件电路原理 : PCI和PCI-E PCI（外围部件互连） 是由 Intel 推出的一种局部总线， 作为一种通用的总线接口标准 PCI总线具有如下特点 : 数据总线为32位， 可扩充到64位 可进行突发（Burst） 模式传输。 突发方式传输是指取得总线控制权后连续进行多个数据的传输。 突发传输时， 只需要给出目的地的首地址， 访问第1个数据后， 第2～n个数据会在首地址的基础上按一定规则自动寻址和传输。 与突发方式对应的是单周期方式， 它在1个总线周期只传送1个数据。 总线操作与处理器——存储器子系统操作并行 采用中央集中式总线仲裁 支持全自动配置、 资源分配， PCI卡内有设备信息寄存器组为系统提供卡的信息， 可实现即插即用 PCI总线规范独立于微处理器， 通用性好 PCI设备可以完全作为主控设备控制总线 基于PCI总线的计算机系统逻辑示意图 : 系统的各个部分通过PCI总线和PCI-PCI桥连接在一起 CPU和RAM通过PCI桥连接到PCI总线0（即主PCI总线） ， 而具有PCI接口的显卡则可以直接连接到主PCI总线上。 PCI-PCI桥是一个特殊的PCI设备， 它负责将 PCI总线0 和 PCI总线1（即从PCI主线） 连接在一起， 通常PCI总线1称为 PCI-PCI桥的下游（Downstream） ， 而PCI总线0则称为 PCI-PCI桥的上游（Upstream） 。 为了兼容旧的ISA总线标准， PCI总线还可以通过 PCI-ISA桥 来连接ISA总线， 从而支持以前的ISA设备。 PCI配置空间 : PCI配置空间共为256字节 = (3CH + 04H)* 4 : 制造商标识（Vendor ID） ： 由PCI组织分配给厂家 设备标识（Device ID） ： 按产品分类给本卡的编号 分类码（Class Code） ： 本卡功能的分类码， 如图卡、 显示卡、 解压卡等 申请存储器空间： PCI卡内有存储器 或 以存储器编址的寄存器和I/O空间， 为使驱动程序和应用程序能访问它们， 需申请CPU的一段存储区域以进行定位。 配置空间的基地址寄存器用于此目的 申请I/O空间： 配置空间中的基地址寄存器用来进行系统I/O空间的申请 中断资源申请： 配置空间中的中断引脚和中断线用来向系统申请中断资源。 偏移 3D H 处为中断引脚寄存器， 其值表明PCI设备使用了哪一个中断引脚， 对应关系为1—INTA#、 2—INTB#、 3—INTC#、 4—INTD# PCI-E（ PCI Express） 是Intel公司提出的新一代的总线接口， PCI Express采用了目前业内流行的点对点串行连接， 比起PCI以及更早的计算机总线的共享并行架构， 每个设备都有自己的专用连接， 采用串行方式传输数据， 并把数据传输率提高到一个很高的频率， 达到PCI所不能提供的高带宽。 SD和SDIO SD（Secure Digital） 是一种关于Flash存储卡的标准， 也就是一般常见的SD记忆卡， 在设计上与MMC（Multi-Media Card） 保持了兼容 SDHC（SDHigh Capacity） 是大容量SD卡， 支持的最大容量为32GB。 SDXC（SD eXtended Capacity） 则支持最大2TB大小的容量 SDIO（Secure Digital Input and Output Card， 安全数字输入输出卡） 在SD标准的基础上， 定义了除存储卡以外的外设接口。 SDIO主要有两类应用——可移动和不可移动。 不可移动设备遵循相同的电气标准， 但不要求符合物理标准。 有很多的手机或者手持装置都支持SDIO的功能， 以连接WiFi、 蓝牙、 GPS等模块。 SD/SDIO的传输模式有： SPI模式 1位模式 4位模式 SDIO接口引脚定义 : CLK为时钟引脚， 每个时钟周期传输一个命令 或 数据位； CMD是命令引脚， 命令在CMD线上串行传输， 是双向半双工的（命令从主机到从卡， 而命令的响应是从卡发送到主机） DAT[0] ~ DAT[3]为数据线引脚； 在SPI模式中， 第8脚位被当成中断信号 SDIO单模块读、 写的典型时序 : eMMC（ Embedded Multi Media Card） 是当前移动设备本地存储的主流解决方案， 目的在于简化手机存储器的设计。 eMMC就是NAND Flash、 闪存控制芯片和标准接口封装的集合， 它把NAND和控制芯片封装成为一个多芯片封装（ Multi-Chip Package， MCP） 芯片。 eMMC支持 DAT[0] ~ DAT[7] 8位的数据线。 上电或者复位后， 默认处于1位模式， 只使用DAT[0]， 后续可以配置为4位或者8位模式。 CPLD和FPGA CPLD（复杂可编程逻辑器件） 由 完全可编程的与或门阵列 以及 宏单元构成。 CPLD中的基本逻辑单元是宏单元， 宏单元由一些“ 与或 ”阵列加上 触发器 构成， 其中“ 与或 ”阵列完成 组合逻辑 功能， 触发器完成 时序逻辑 功能。 宏单元中与阵列的输出称为乘积项， 其数量标示着CPLD的容量。 乘积项阵列实际上就是一个“与或”阵列， 每一个交叉点都是一个可编程熔丝， 如 导通就是实现“与”逻辑。 在“ 与 ”阵列后一般还有一个“ 或 ”阵列， 用以完成最小逻辑表达式中的“ 或 ”关系。 典型的CPLD的单个宏单元结构 CPLD由 LAB（逻辑阵列模块， 由多个宏单元组成） 通过PIA（可编程互连阵列） 互连组成， 而CPLD与外部的接口则由I/O控制模块提供。 宏单元的输出会经I/O控制块送至I/O引脚， I/O控制块控制每一个I/O引脚的工作模式， 决定其为输入、 输出还是双向引脚， 并决定其三态输出的使能端控制。 典型的CPLD整体架构 FPGA由IOC（输入/输出控制模块） 、 EAB（嵌入式阵列块） 、 LAB和快速通道互连构成 IOC是内部信号到I/O引脚的接口， 它位于快速通道的行和列的末端， 每个IOC包含一个双向I/O缓冲器和一个既可作为输入寄存器也可作为输出寄存器的触发器 EAB（嵌入式存储块） 是一种输入输出端带有寄存器的非常灵活的RAM。 EAB不仅可以用作存储器， 还可以事先写入查表值以用来构成如乘法器、 纠错逻辑等电路。 当用于RAM时， EAB可配制成8位、 4位、 2位和1位长度的数据格式 LAB主要用于逻辑电路设计， 一个LAB包括多个LE（逻辑单元） ， 每个LE包括组合逻辑及一个可编程触发器。 一系列LAB构成的逻辑阵列可实现普通逻辑功能， 如计数器、 加法器、 状态机等 典型的FPGA内部结构 : 器件内部信号的互连和器件引出端之间的信号互连由快速通道连线提供， 快速通道遍布于整个FPGA器件中， 是一系列水平和垂直走向的连续式布线通道。 实际逻辑电路与查找表的实现 : 原理图分析 硬件时序分析 时序分析的概念 典型的硬件时序 芯片数据手册阅读方法 仪器仪表使用 万用表 示波器 逻辑分析仪 Linux内核及内核编程 Linux内核的发展与演变 Linux操作系统是UNIX操作系统的一种克隆系统 UNIX操作系统 鼻祖 Minix操作系统 Minix操作系统也是UNIX的一种克隆系统 GNU计划 GNU项目已经开发出许多高质量的免费软件， 其中包括 emacs编辑系统、 bash shell程序、 gcc系列编译程序、 GDB调试程序等 . 为Linux操作系统的开发创造了一个合适的环境 POSIX标准 POSIX（Portable Operating System Interface， 可移植的操作系统接口） 是由IEEE和ISO/IEC开发的一组标准。 基于UNIX， 描述了操作系统的调用服务接口， 用于保证编写的应用程序的移植 Linux操作系统版本的历史及特点 : android采用Linux内核， 并在内核里加入了一系列补丁 Linux内核开发人员和补丁情况 : Linux 2.6后的内核特点 新的调度器 CFS（Completely FairScheduler， 完全公平调度） 算法 Linux 3.14 中: 增加 EDF（Earliest Deadline First， 最早截止期限优先） 调度算法 内核抢占 一个内核任务可以被抢占， 从而提高系统的实时性 Linux 2.4的内核中， 在IRQ1的中断服务程序唤醒RT（实时） 任务后， 必须要等待前面一个Normal（普通） 任务的系统调用完成， 返回用户空间的时候， RT任务才能切入 Linux 2.6内核中， Normal任务的临界区（如自旋锁） 结束的时候， RT任务就从内核切入 Linux 2.6以后的内核仍然存在中断、 软中断、 自旋锁等原子上下文进程无法抢占执行 Linux 2.4和2.6以后的内核在抢占上的区别 : 改进的线程模型 虚拟内存的变化 文件系统 音频 总线、 设备和驱动模型 电源管理 联网和IPSec 用户界面层 Linux 3.0后ARM架构的变更 Linux内核的组成 Linux内核源代码的目录结构 Linux内核的组成部分 Linux内核空间与用户空间 Linux内核的编译及加载 Linux下的C编程特点 工具链 实验室建设 串口工具 Linux内核模块 Linux内核模块简介 Linux内核模块程序结构 模块加载函数 模块卸载函数 Linux文件系统与设备文件 Linux文件操作 字符设备驱动 Linux设备驱动中的并发控制 Linux设备驱动中的阻塞与非阻塞I/O Linux设备驱动中的异步通知与异步I/O 中断与时钟 内存与I/O访问 Linux设备驱动的软件架构思想 Linux块设备驱动 Linux网络设备驱动 Linux I2C核心、 总线与设备驱动 USB主机、 设备与Gadget驱动 I2C、 SPI、 USB驱动架构类比 ARM Linux设备树 Linux电源管理的系统架构和驱动 Linux芯片级移植及底层驱动 Linux设备驱动的调试 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:08:16 "},"android_bottom/hardware_abstraction_layer.html":{"url":"android_bottom/hardware_abstraction_layer.html","title":"硬件抽象层","keywords":"","body":" 硬件抽象层 @Author: cpu_code @Date: 2020-07-12 22:20:34 @LastEditTime: 2020-07-13 22:52:02 @FilePath: \\notes\\android_bottom\\hardware_abstraction_layer.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ Android系统的硬件抽象层（Hardware Abstract Layer， HAL） 运行在用户空间中， 它向下屏蔽硬件驱动模块的实现细节， 向上提供硬件访问服务。 Android系统的体系结构 : 开发Android硬件驱动程序 实现内核驱动程序模块 驱动程序freg的目录结构 : ~/Android/kernel/goldfish drivers freg freg.h # 源代码文件 freg.c # 源代码文件 Kconfig # 编译选项配置文件 Makefile # 编译脚本文件 freg.h : // kernel\\goldfish\\drivers\\freg\\freg.h #ifndef _FAKE_REG_H_ #define _FAKE_REG_H_ #include #include //定义了四个字符串常量，分别用来描述虚拟硬件设备 freg 在设备文件系统中的名称 #define FREG_DEVICE_NODE_NAME \"freg\" #define FREG_DEVICE_FILE_NAME \"freg\" #define FREG_DEVICE_PROC_NAME \"freg\" #define FREG_DEVICE_CLASS_NAME \"freg\" // 描述虚拟硬件设备freg struct fake_reg_dev { // 描述一个虚拟寄存器 int val; // 一个信号量, 用来同步访问虚拟寄存器 val struct semaphore sem; // 一个标准的Linux字符设备结构体变量， 用来标志该虚拟硬件设备 freg 的类型为字符设备 struct cdev dev; }; #endif freg.c // kernel\\goldfish\\drivers\\freg\\freg.c #include #include #include #include #include #include #include #include \"freg.h\" /* 主设备号 */ static int freg_major = 0; /* 从设备号变量 */ static int freg_minor = 0; /* 设备类别 */ static struct class* freg_class = NULL; /* 设备变量 */ static struct fake_reg_dev* freg_dev = NULL; /* 传统的设备文件操作方法 */ static int freg_open(struct inode* inode, struct file* filp); static int freg_release(struct inode* inode, struct file* filp); static ssize_t freg_read(struct file* filp, char __user *buf, size_t count, loff_t* f_pos); static ssize_t freg_write(struct file* filp, const char __user *buf, size_t count, loff_t* f_pos); /* 传统的设备文件操作方法表 */ static struct file_operations freg_fops = { .owner = THIS_MODULE, .open = freg_open, .release = freg_release, .read = freg_read, .write = freg_write, }; /* devfs文件系统的设备属性操作方法 */ static ssize_t freg_val_show(struct device* dev, struct device_attribute* attr, char* buf); static ssize_t freg_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count); /* devfs文件系统的设备属性 */ static DEVICE_ATTR(val, S_IRUGO | S_IWUSR, freg_val_show, freg_val_store); /* 打开设备方法 */ static int freg_open(struct inode* inode, struct file* filp) { struct fake_reg_dev* dev; //将自定义设备结构体保存在文件指针的私有数据域中, 以便访问设备时可以直接拿来用 dev = container_of(inode->i_cdev, struct fake_reg_dev, dev); filp->private_data = dev; return 0; } /* 设备文件释放时调用, 空实现 */ static int freg_release(struct inode* inode, struct file* filp) { return 0; } /* 读取设备的寄存器val的值 */ static ssize_t freg_read(struct file* filp, char __user *buf, size_t count, loff_t* f_pos) { ssize_t err = 0; struct fake_reg_dev* dev = filp->private_data; /* 同步访问 */ if(down_interruptible(&(dev->sem))) { return -ERESTARTSYS; } if(count val)) { goto out; } /* 将寄存器val的值复制到用户提供的缓冲区中 */ if(copy_to_user(buf, &(dev->val), sizeof(dev->val))) { err = -EFAULT; goto out; } err = sizeof(dev->val); out: up(&(dev->sem)); return err; } /* 写设备的寄存器val的值 */ static ssize_t freg_write(struct file* filp, const char __user *buf, size_t count, loff_t* f_pos) { struct fake_reg_dev* dev = filp->private_data; ssize_t err = 0; /* 同步访问 */ if(down_interruptible(&(dev->sem))) { return -ERESTARTSYS; } if(count != sizeof(dev->val)) { goto out; } /* 将用户提供的缓冲区的值写到设备寄存器中 */ if(copy_from_user(&(dev->val), buf, count)) { err = -EFAULT; goto out; } err = sizeof(dev->val); out: up(&(dev->sem)); return err; } /* 将寄存器val的值读取到缓冲区buf中, 内部使用 */ static ssize_t __freg_get_val(struct fake_reg_dev* dev, char* buf) { int val = 0; /* 同步访问 */ if(down_interruptible(&(dev->sem))) { return -ERESTARTSYS; } val = dev->val; up(&(dev->sem)); return snprintf(buf, PAGE_SIZE, \"%d\\n\", val); } /* 把缓冲区buf的值写到设备寄存器val中, 内部使用 */ static ssize_t __freg_set_val(struct fake_reg_dev* dev, const char* buf, size_t count) { int val = 0; /* 将字符串转换为数字 */ val = simple_strtol(buf, NULL, 10); /* 同步访问 */ if(down_interruptible(&(dev->sem))) { return -ERESTARTSYS; } dev->val = val; up(&(dev->sem)); return count; } /* 读设备属性val的值 */ static ssize_t freg_val_show(struct device* dev, struct device_attribute* attr, char* buf) { struct fake_reg_dev* hdev = (struct fake_reg_dev*)dev_get_drvdata(dev); return __freg_get_val(hdev, buf); } /* 写设备属性val的值 */ static ssize_t freg_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count) { struct fake_reg_dev* hdev = (struct fake_reg_dev*)dev_get_drvdata(dev); return __freg_set_val(hdev, buf, count); } /* 读取设备寄存器 val 的值 , 保存到page 缓冲区中*/ static ssize_t freg_proc_read(char* page, char** start, off_t off, int count, int* eof, void* data) { if(off > 0) { *eof = 1; return 0; } return __freg_get_val(freg_dev, page); } /* 把缓冲区的值 buff 保存到设备寄存器 val 中 */ static ssize_t freg_proc_write(struct file* filp, const char __user *buff, unsigned long len, void* data) { int err = 0; char* page = NULL; if(len > PAGE_SIZE) { printk(KERN_ALERT\"The buff is too large: %lu.\\n\", len); return -EFAULT; } page = (char*)__get_free_page(GFP_KERNEL); if(!page) { printk(KERN_ALERT\"Failed to alloc page.\\n\"); return -ENOMEM; } /* 先把用户提供的缓冲区的值复制到内核缓冲区中 */ if(copy_from_user(page, buff, len)) { printk(KERN_ALERT \"Failed to copy buff from user.\\n\"); err = -EFAULT; goto out; } err = __freg_set_val(freg_dev, page, len); out: free_page((unsigned long)page); return err; } /* 创建 /proc/freg 文件 */ static void freg_create_proc(void) { struct proc_dir_entry* entry; entry = create_proc_entry(FREG_DEVICE_PROC_NAME, 0, NULL); if(entry) { entry->owner = THIS_MODULE; entry->read_proc = freg_proc_read; entry->write_proc = freg_proc_write; } } /* 删除 /proc/freg 文件 */ static void freg_remove_proc(void) { remove_proc_entry(FREG_DEVICE_PROC_NAME, NULL); } /* 初始化设备 */ static int __freg_setup_dev(struct fake_reg_dev* dev) { int err; dev_t devno = MKDEV(freg_major, freg_minor); memset(dev, 0, sizeof(struct fake_reg_dev)); /* 初始化字符设备 */ cdev_init(&(dev->dev), &freg_fops); dev->dev.owner = THIS_MODULE; dev->dev.ops = &freg_fops; /* 注册字符设备 */ err = cdev_add(&(dev->dev),devno, 1); if(err) { return err; } /* 初始化信号量 */ init_MUTEX(&(dev->sem)); /* 初始化寄存器val的值 */ dev->val = 0; return 0; } /* 模块加载方法 */ static int __init freg_init(void) { int err = -1; dev_t dev = 0; struct device* temp = NULL; printk(KERN_ALERT\"Initializing freg device.\\n\"); /* 动态分配主设备号 和 从设备号 */ err = alloc_chrdev_region(&dev, 0, 1, FREG_DEVICE_NODE_NAME); if(err dev)); cleanup: kfree(freg_dev); unregister: unregister_chrdev_region(MKDEV(freg_major, freg_minor), 1); fail: return err; } /* 模块卸载方法 */ static void __exit freg_exit(void) { dev_t devno = MKDEV(freg_major, freg_minor); printk(KERN_ALERT\"Destroy freg device.\\n\"); /* 删除 /proc/freg 文件 */ freg_remove_proc(); /* 注销设备类别 和 设备 */ if(freg_class) { device_destroy(freg_class, MKDEV(freg_major, freg_minor)); class_destroy(freg_class); } /* 删除字符设备 和 释放设备内存 */ if(freg_dev) { cdev_del(&(freg_dev->dev)); kfree(freg_dev); } /* 释放设备号资源 */ unregister_chrdev_region(devno, 1); } MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"Fake Register Driver\"); module_init(freg_init); module_exit(freg_exit); Kconfig : # kernel\\goldfish\\drivers\\freg\\Kconfig config FREG tristate \"Fake Register Driver\" default n help This is the freg driver for android system. Makefile : # kernel\\goldfish\\drivers\\freg\\Makefile # $（CONFIG_FREG） 是一个变量， 它的值与驱动程序freg的编译选项有关 #如果选择将驱动程序freg内建到内核中， 那么变量$（CONFIG_FREG） 的值为y； # 如果选择以模块的方式来编译驱动程序freg， 那么变量$（CONFIG_FREG） 的值为m； # 如果变量$（CONFIG_FREG） 的值既不为y， 也不为m，那么驱动程序freg就不会被编译 obj-$(CONFIG_FREG) += freg.o 修改内核Kconfig文件 # arch/arm/Kconfig menu \"Device Drivers\" # 将驱动程序freg的Kconfig文件包含进来 source \"drivers/freg/Kconfig\" source \"drivers/base/Kconfig\" source \"drivers/connector/Kconfig\" # ... endmenu # drivers/Kconfig menu \"Device Drivers\" # 将驱动程序 freg 的 Kconfig 文件包含进来 source \"drivers/freg/Kconfig\" source \"drivers/base/Kconfig\" # ... endmenu 修改内核Makefile文件 # drivers/Makefile # 当 make 编译内核时，编译系统就会对驱动程序 freg 进行编译 obj-$(CONFIG_FREG) += freg/ obj-y += gpio/ obj-$(CONFIG_PCI) += pci/ # ... 编译内核驱动程序模块 在编译驱动程序freg之前， 我们需要执行make menuconfig命令来配置它的编译方式 make menuconfig 执行make命令来编译驱动程序freg make 驱动程序freg编译成功 : 验证内核驱动程序模块 # 使用 得到的内核镜像文件zImage来启动Android模拟器 emulator -kernel kernel/goldfish/arch/arm/boot/zImage & # # 用adb工具连接上 adb shell # 进入 /dev目录下 cd dev # 查看 一个设备文件freg ls freg # 进入到/proc cd proc # 读取文件freg的内容 cat freg # 往文件freg中写入一个新的内容 echo '5' > freg # 将文件freg的内容读取出来 cat freg # 进入到/sys/class/freg/freg cd sys/class/freg/freg # 读取val文件的内容 cat val # 往文件val中写入一个新的内容 echo '' > freg # 将文件val中的内容读取出 cat freg 开发C可执行程序验证Android硬件驱动程序 在Android源代码工程环境中开发的C可执行程序源文件一般保存在external目录中，因此， 我们进入到external目录中， 并且创建一个freg目录， 用来保存我们将要开发的C可执行程序源文件。 目录结构 : ~/Android exiternal freg freg.c Android.mk 源文件freg.c : #include #include #include #define FREG_DEVICE_NAME \"/dev/freg\" int main(int argc, char** argv) { int fd = -1; int val = 0; // 以读写方式打开设备文件/dev/freg fd = open(FREG_DEVICE_NAME, O_RDWR); if(fd == -1) { printf(\"Failed to open device %s.\\n\", FREG_DEVICE_NAME); return -1; } printf(\"Read original value:\\n\"); // 读取它的内容， 即读取虚拟硬件设备 freg 的寄存器 val 的内容 read(fd, &val, sizeof(val)); // 打印出来 printf(\"%d.\\n\\n\", val); val = 5; printf(\"Write value %d to %s.\\n\\n\", val, FREG_DEVICE_NAME); // 将一个整数 5 写入到虚拟硬件设备 freg 的寄存器 val 中 write(fd, &val, sizeof(val)); printf(\"Read the value again:\\n\"); // 读取它的内容， 即读取虚拟硬件设备 freg 的寄存器 val 的内容 read(fd, &val, sizeof(val)); // 打印 printf(\"%d.\\n\\n\", val); close(fd); return 0; } 编译脚本文件Android.mk : # 将编译结果保存在 out/target/product/gerneric/system/bin 目录中 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_MODULE := freg LOCAL_SRC_FILES := $(call all-subdir-c-files) # 当前要编译的是一个可执行应用程序模块 include $(BUILD_EXECUTABLE) # 编译 mmm ./external/freg/ # 打包这个C可执行程序 make snod # 将得到的 system.img 文件启动 Android模拟器 emulator -kernal kernel/goldfish/arch/arm/boot/zImage & # adb工具连接上它 adb shell # 进入到/system/bin目录中 cd system/bin # 执行里面的freg文件 ./freg 开发Android硬件抽象层模块 硬件抽象层模块编写规范 硬件抽象层模块文件命名规范 硬件抽象层模块文件的命名规范 : // hardware/libhardware/hardware.c /** * There are a set of variant filename for modules. The form of the filename * is \".variant.so\" so for the led module the Dream variants * of base \"ro.product.board\", \"ro.board.platform\" and \"ro.arch\" would be: * * MODULE_ID : 模块的ID * led.trout.so * led.msm7k.so * led.ARMV6.so * led.default.so */ // variant 表示四个系统属性 ro.hardware、 ro.product.board、 ro.board.platform 和 ro.arch 之一 static const char *variant_keys[] = { \"ro.hardware\", /* 由 init 进程负责设置 */ /* This goes first so that it can pick up a different file on the emulator. */ \"ro.product.board\", \"ro.board.platform\", \"ro.arch\" }; 　硬件抽象层模块结构体定义规范 结构体hw_module_t : // hardware\\libhardware\\include\\hardware\\hardware.h /* * Value for the hw_module_t.tag field */ #define MAKE_TAG_CONSTANT(A,B,C,D) (((A) struct hw_module_methods_t : // hardware\\libhardware\\include\\hardware\\hardware.h typedef struct hw_module_methods_t { /** Open a specific device */ /** * @function: 打开硬件抽象层模块中的硬件设备 * @parameter: * module : 要打开的硬件设备所在的模块 * id : 要打开的硬件设备的ID * device : 一个输出参数，描述一个已经打开的硬件设备 * @return: * success: * error: * @note: */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device); } hw_module_methods_t; struct hw_device_t : // hardware\\libhardware\\include\\hardware\\hardware.h #define HARDWARE_DEVICE_TAG MAKE_TAG_CONSTANT('H', 'W', 'D', 'T') /** * Every device data structure must begin with hw_device_t * followed by module specific public methods and attributes. */ /* * 硬件抽象层模块中的每一个硬件设备都必须自定义一个硬件设备结构体， * 而且它的第一个成员变量的类型必须为hw_device_t */ typedef struct hw_device_t { /** tag must be initialized to HARDWARE_DEVICE_TAG */ /* * tag 必须 == HARDWARE_DEVICE_TAG，即设置为一个常量值（'H'＜＜24|'W'＜＜16|'D'＜＜8|'T'）, * 用来标志这是一个硬件抽象层中的硬件设备结构体 */ uint32_t tag; /** version number for hw_device_t */ uint32_t version; /** reference to the module this device belongs to */ struct hw_module_t* module; /** padding reserved for future use */ uint32_t reserved[12]; /** Close this device */ /* 关闭一个硬件设备 */ int (*close)(struct hw_device_t* device); } hw_device_t; 编写硬件抽象层模块接口 将虚拟硬件设备freg在硬件抽象层中的模块名称定义为freg 目录结构： ~/Android/hardware/libhardware include hardware freg.h Modules freg freg.cpp Android.mk freg.h 源代码文件 // Android/hardware/libhardware/include/hardware/freg.h #ifndef ANDROID_FREG_INTERFACE_H #define ANDROID_FREG_INTERFACE_H __BEGIN_DECLS /** * The id of this module */ // 定义模块ID #define FREG_HARDWARE_MODULE_ID \"freg\" /** * The id of this device */ // 定义设备ID #define FREG_HARDWARE_DEVICE_ID \"freg\" // 自定义模块结构体 struct freg_module_t { // 第一个成员变量的类型为 hw_module_t struct hw_module_t common; }; // 自定义设备结构体 , 描述虚拟硬件设备 freg struct freg_device_t { // 第一个成员变量的类型为 hw_device_t struct hw_device_t common; // 一个文件描述符 , 用来描述打开的设备文件/dev/freg int fd; // 写虚拟硬件设备 freg 的寄存器 val 的内容 int (*set_val)(struct freg_device_t* dev, int val); // 读虚拟硬件设备 freg 的寄存器 val 的内容 int (*get_val)(struct freg_device_t* dev, int* val); }; __END_DECLS #endif freg.cpp 硬件抽象层模块 freg 的实现文件 : // Android/hardware/libhardware/Modules/freg/freg.cpp #define LOG_TAG \"FregHALStub\" #include #include #include #include #include #include #define DEVICE_NAME \"/dev/freg\" #define MODULE_NAME \"Freg\" #define MODULE_AUTHOR \"cpucode\" /* 设备打开接口 */ static int freg_device_open(const struct hw_module_t* module, const char* id, struct hw_device_t** device); /* 设备关闭接口 */ static int freg_device_close(struct hw_device_t* device); /* 设备寄存器写接口 */ static int freg_set_val(struct freg_device_t* dev, int val); /* 设备寄存器读接口 */ static int freg_get_val(struct freg_device_t* dev, int* val); /* 定义模块操作方法结构体变量 */ static struct hw_module_methods_t freg_module_methods = { open: freg_device_open }; /* 定义模块结构体变量 */ // 每一个硬件抽象层模块必须导出一个名称为 HAL_MODULE_INFO_SYM 的符号 struct freg_module_t HAL_MODULE_INFO_SYM = { common: { // tag 必须 == HARDWARE_MODULE_TAG tag: HARDWARE_MODULE_TAG, version_major: 1, version_minor: 0, id: FREG_HARDWARE_MODULE_ID, name: MODULE_NAME, author: MODULE_AUTHOR, methods: &freg_module_methods, } }; // 打开操作 static int freg_device_open(const struct hw_module_t* module, const char* id, struct hw_device_t** device) { // 判断 id 与虚拟硬件设备freg的ID值是否 匹配 if(!strcmp(id, FREG_HARDWARE_DEVICE_ID)) { struct freg_device_t* dev; dev = (struct freg_device_t*)malloc(sizeof(struct freg_device_t)); if(!dev) { LOGE(\"Failed to alloc space for freg_device_t.\"); return -EFAULT; } memset(dev, 0, sizeof(struct freg_device_t)); // 硬件设备标签（dev-＞common.tag） 必须 == HARDWARE_DEVICE_TAG dev->common.tag = HARDWARE_DEVICE_TAG; dev->common.version = 0; dev->common.module = (hw_module_t*)module; // 关闭函数设置为 freg_device_close dev->common.close = freg_device_close; // 写函数 dev->set_val = freg_set_val; // 读函数 dev->get_val = freg_get_val; // 打开虚拟硬件设备文件/dev/freg ， 且将得到的文件描述符保存在结构体 freg_device_t 的成员变量 fd 中 if((dev->fd = open(DEVICE_NAME, O_RDWR)) == -1) { LOGE(\"Failed to open device file /dev/freg -- %s.\", strerror(errno)); free(dev); return -EFAULT; } *device = &(dev->common); LOGI(\"Open device file /dev/freg successfully.\"); return 0; } return -EFAULT; } // 虚拟硬件设备freg的关闭函数 static int freg_device_close(struct hw_device_t* device) { struct freg_device_t* freg_device = (struct freg_device_t*)device; if(freg_device) { // 关闭设备文件/dev/freg close(freg_device->fd); // 释放设备 free(freg_device); } return 0; } static int freg_set_val(struct freg_device_t* dev, int val) { if(!dev) { LOGE(\"Null dev pointer.\"); return -EFAULT; } LOGI(\"Set value %d to device file /dev/freg.\", val); // 写虚拟硬件设备freg的寄存器val的内容 write(dev->fd, &val, sizeof(val)); return 0; } static int freg_get_val(struct freg_device_t* dev, int* val) { if(!dev) { LOGE(\"Null dev pointer.\"); return -EFAULT; } if(!val) { LOGE(\"Null val pointer.\"); return -EFAULT; } // 读虚拟硬件设备freg的寄存器val的内容 read(dev->fd, val, sizeof(*val)); LOGI(\"Get value %d from device file /dev/freg.\", *val); return 0; } Android.mk 编译脚本文件 : # Android/hardware/libhardware/Modules/freg/Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_PRELINK_MODULE := false # 保存在 out/target/product/generic/system/lib/hw LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw LOCAL_SHARED_LIBRARIES := liblog LOCAL_SRC_FILES := freg.cpp LOCAL_MODULE := freg.default # 将该硬件抽象层模块编译成一个动态链接库文件， 名称为 freg.default include $(BUILD_SHARED_LIBRARY) # 编译 mmm ./hardware/libhardware/moduels/freg/ # 打包 make snod # 在 out/target/product/generic/system/lib/hw 目录下得到一个 freg.default.so 文件 硬件抽象层模块的加载过程 负责加载硬件抽象层模块的函数 hw_get_module : // hardware\\libhardware\\include\\hardware\\hardware.h /** * Get the module info associated with a module by id. * @return: 0 == success, 分析hw_get_module函数的实现 : // hardware\\libhardware\\hardware.c /** Base path of the hal modules */ // 定义要加载的硬件抽象层模块文件所在的目录 // 编译好的模块文件位于 out/target/product/generic/system/lib/hw 目录中， //而这个目录经过打包后， 就对应于设备上的 /system/lib/hw 目录 #define HAL_LIBRARY_PATH1 \"/system/lib/hw\" // 定义的目录为 /vendor/lib/hw ，用来保存设备厂商所提供的硬件抽象层模块接口文件 #define HAL_LIBRARY_PATH2 \"/vendor/lib/hw\" /** * There are a set of variant filename for modules. The form of the filename * is \".variant.so\" so for the led module the Dream variants * of base \"ro.product.board\", \"ro.board.platform\" and \"ro.arch\" would be: * * led.trout.so * led.msm7k.so * led.ARMV6.so * led.default.so */ // 组装要加载的硬件抽象层模块的文件名称 static const char *variant_keys[] = { \"ro.hardware\", /* This goes first so that it can pick up a different file on the emulator. */ \"ro.product.board\", \"ro.board.platform\", \"ro.arch\" }; // 数组 variant_keys的大小 static const int HAL_VARIANT_KEYS_COUNT = (sizeof(variant_keys)/ sizeof(variant_keys[0])); int hw_get_module(const char *id, const struct hw_module_t **module) { int status; int i; const struct hw_module_t *hmi = NULL; char prop[PATH_MAX]; char path[PATH_MAX]; /* * Here we rely on the fact that calling dlopen multiple times on * the same .so will simply increment a refcount (and not load * a new copy of the library). * We also assume that dlopen() is thread-safe. */ /* Loop through the configuration variants looking for a module */ for (i = 0 ; i load 函数来执行硬件抽象层模块的加载操作 : // hardware\\libhardware\\hardware.c /** * Load the file defined by the variant and if successful * return the dlopen handle and the hmi. * @return 0 = success, !0 = failure. */ static int load(const char *id, const char *path, const struct hw_module_t **pHmi) { int status; void *handle; struct hw_module_t *hmi; /* * load the symbols resolving undefined symbols before * dlopen returns. Since RTLD_GLOBAL is not or'd in with * RTLD_NOW the external symbols will not be global */ /* 将它加载到内存中 */ handle = dlopen(path, RTLD_NOW); if (handle == NULL) { char const *err_str = dlerror(); LOGE(\"load: module=%s\\n%s\", path, err_str?err_str:\"unknown\"); status = -EINVAL; goto done; } /* Get the address of the struct hal_module_info. */ const char *sym = HAL_MODULE_INFO_SYM_AS_STR; // 获得里面名称为 HAL_MODULE_INFO_SYM_AS_STR 的符号 // 符号指向的是一个自定义的硬件抽象层模块结构体， // 它包含了对应的硬件抽象层模块的所有信息 // 将模块中的 HMI 符号转换为一个 hw_module_t 结构体指针 hmi = (struct hw_module_t *)dlsym(handle, sym); if (hmi == NULL) { LOGE(\"load: couldn't find symbol %s\", sym); status = -EINVAL; goto done; } /* Check that the id matches */ /* 验证加载得到的硬件抽象层模块ID 是否 与所要求加载的硬件抽象层模块ID一致 */ if (strcmp(id, hmi->id) != 0) { LOGE(\"load: id=%s != hmi->id=%s\", id, hmi->id); status = -EINVAL; goto done; } //将成功加载后得到的模块句柄值 handle 保存在 hw_module_t 结构体指针 hmi 的成员变量 dso 中 hmi->dso = handle; /* success */ status = 0; done: if (status != 0) { hmi = NULL; if (handle != NULL) { dlclose(handle); handle = NULL; } } else { LOGV(\"loaded HAL id=%s path=%s hmi=%p handle=%p\", id, path, *pHmi, handle); } *pHmi = hmi; return status; } 　处理硬件设备访问权限问题 // Android/hardware/libhardware/Modules/freg/freg.cpp // 打开操作 static int freg_device_open(const struct hw_module_t* module, const char* id, struct hw_device_t** device) { // 判断 id 与虚拟硬件设备freg的ID值是否 匹配 if(!strcmp(id, FREG_HARDWARE_DEVICE_ID)) { struct freg_device_t* dev; dev = (struct freg_device_t*)malloc(sizeof(struct freg_device_t)); if(!dev) { LOGE(\"Failed to alloc space for freg_device_t.\"); return -EFAULT; } memset(dev, 0, sizeof(struct freg_device_t)); // 硬件设备标签（dev-＞common.tag） 必须 == HARDWARE_DEVICE_TAG dev->common.tag = HARDWARE_DEVICE_TAG; dev->common.version = 0; dev->common.module = (hw_module_t*)module; // 关闭函数设置为 freg_device_close dev->common.close = freg_device_close; // 写函数 dev->set_val = freg_set_val; // 读函数 dev->get_val = freg_get_val; // 打开虚拟硬件设备文件/dev/freg ， 且将得到的文件描述符保存在结构体 freg_device_t 的成员变量 fd 中 // 不修改设备文件/dev/freg的访问权限 , 打不开 if((dev->fd = open(DEVICE_NAME, O_RDWR)) == -1) { LOGE(\"Failed to open device file /dev/freg -- %s.\", strerror(errno)); free(dev); return -EFAULT; } *device = &(dev->common); LOGI(\"Open device file /dev/freg successfully.\"); return 0; } return -EFAULT; } Android提供了另外的一个uevent机制， 可以在系统启动时修改设备文件的访问权限 # system\\core\\rootdir\\ueventd.rc # ... /dev/binder 0666 root root /dev/freg 0666 root root # logger should be world writable (for logging) but not readable /dev/log/* 0662 root log # the msm hw3d client device node is world writable/readable. /dev/msm_hw3dc 0666 root root # gpu driver for adreno200 is globally accessible /dev/kgsl 0666 root root #... 解压ramdisk.img镜像文件 # 将ramdisk.img改名为ramdisk.img.gz mv ./out/target/product/generic/reamdisk.img ./reamdisk.img.gz # 解压 gunzip ./ramdisk.img.gz 还原ramdisk.img镜像文件 # 创建目录 mkdir ramdisk # 进入目录 cd ./ramdisk/ # 解除归档 cpio -i -F ../ramdisk.img 修改ueventd.rc文件 # 进入目录 cd /ramdisk # 修改 文件 vim ueventd.rc # system\\core\\rootdir\\ueventd.rc # ... /dev/binder 0666 root root # 赋予了系统中的所有用户访问设备文件/dev/freg的权限 /dev/freg 0666 root root # logger should be world writable (for logging) but not readable /dev/log/* 0662 root log # the msm hw3d client device node is world writable/readable. /dev/msm_hw3dc 0666 root root # gpu driver for adreno200 is globally accessible /dev/kgsl 0666 root root #... 重新打包ramdisk.img镜像文件 # 删除 rm -f ../ramdisk.img # 把 ramdisk 目录归档成 cpio 文件 find . | cpio -o -H newc > ../ramdisk.img.unzip # 切换到上目录 cd .. # 压缩成gzip文件 gzip -c ./ramdisk.img.unzip > .ramdisk.img.gz # 删除 rm -f ./ramdisk.img.unzip rm -R ./ramdisk # 转移 并改名 mv ./ramdisk.img.gz ./out/target/product/generic/ramdisk.img 开发Android硬件访问服务 定义硬件访问服务接口 // frameworks\\base\\core\\java\\android\\os\\IFregService.aidl package android.os; interface IFregService { // 往虚拟硬件设备freg的寄存器val中写入一个整数 void setVal(int val); // 从虚拟硬件设备freg的寄存器val中读出一个整数 int getVal(); } # frameworks/base/Android.mk ## READ ME: ######################################################## ## ## When updating this list of aidl files, consider if that aidl is ## part of the SDK API. If it is, also add it to the list below that ## is preprocessed and distributed with the SDK. This list should ## not contain any aidl files for parcelables, but the one below should ## if you intend for 3rd parties to be able to send those objects ## across process boundaries. ## ## READ ME: ######################################################## LOCAL_SRC_FILES += \\ core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \\ #... core/java/android/net/IThrottleManager.aidl \\ core/java/android/nfc/IP2pTarget.aidl \\ core/java/android/os/IVibratorService.aidl \\ # 将需要的添加到编译脚本文件中 core/java/android/os/IFregService.aidl \\ core/java/android/service/urlrenderer/IUrlRendererService.aidl \\ #... voip/java/android/net/sip/ISipService.aidl # # 对硬件访问服务接口IFregService进行编译 mmm ./frameworks/base/ 实现硬件访问服务 // frameworks\\base\\services\\java\\com\\android\\server\\FregService.java package com.android.server; import android.content.Context; import android.os.IFregService; import android.util.Slog; // 硬件访问服务FregService继承了IFregService.Stub类 public class FregService extends IFregService.Stub { private static final String TAG = \"FregService\"; private int mPtr = 0; FregService() { // 调用 JNI 方法 init_native 来打开虚拟硬件设备 freg ， // 并且获得它的一个句柄值， 保存在成员变量 mPtr 中 mPtr = init_native(); if(mPtr == 0) { Slog.e(TAG, \"Failed to initialize freg service.\"); } } public void setVal(int val) { if(mPtr == 0) { Slog.e(TAG, \"Freg service is not initialized.\"); return; } // 调用 JNI 方法 setVal_native 来写虚拟硬件设备 freg 的寄存器 val setVal_native(mPtr, val); } public int getVal() { if(mPtr == 0) { Slog.e(TAG, \"Freg service is not initialized.\"); return 0; } //调用 JNI 方法 getVal_native 来读虚拟硬件设备 freg 的寄存器 val return getVal_native(mPtr); } private static native int init_native(); private static native void setVal_native(int ptr, int val); private static native int getVal_native(int ptr); }; # 重新编译 Android 系统的 services 模块 mmm ./frameworks/base/services/java/ 实现硬件访问服务的JNI方法 // frameworks\\base\\services\\jni\\com_android_server_FregService.cpp #define LOG_TAG \"FregServiceJNI\" #include \"jni.h\" #include \"JNIHelp.h\" #include \"android_runtime/AndroidRuntime.h\" #include #include #include #include #include namespace android { //设置虚拟硬件设备 freg 的寄存器的值 static void freg_setVal(JNIEnv* env, jobject clazz, jint ptr, jint value) { int val = value; //将参数 ptr 转换为 freg_device_t 结构体变量 freg_device_t* device = (freg_device_t*)ptr; if(!device) { LOGE(\"Device freg is not open.\"); return; } LOGI(\"Set value %d to device freg.\", val); device->set_val(device, val); } //读取虚拟硬件设备freg的寄存器的值 static jint freg_getVal(JNIEnv* env, jobject clazz, jint ptr) { int val = 0; //将传输ptr转换为 freg_device_t 结构体变量 freg_device_t* device = (freg_device_t*)ptr; if(!device) { LOGE(\"Device freg is not open.\"); return 0; } device->get_val(device, &val); LOGI(\"Get value %d from device freg.\", val); return val; } //打开虚拟硬件设备freg static inline int freg_device_open(const hw_module_t* module, struct freg_device_t** device) { return module->methods->open(module, FREG_HARDWARE_DEVICE_ID, (struct hw_device_t**)device); } //初始化虚拟硬件设备freg static jint freg_init(JNIEnv* env, jclass clazz) { freg_module_t* module; freg_device_t* device; LOGI(\"Initializing HAL stub freg......\"); //加载硬件抽象层模块freg // 根据 FREG_HARDWARE_MODULE_ID 来加载 Android 硬件抽象层模块 freg if(hw_get_module(FREG_HARDWARE_MODULE_ID, (const struct hw_module_t**)&module) == 0) { LOGI(\"Device freg found.\"); //打开虚拟硬件设freg if(freg_device_open(&(module->common), &device) == 0) { LOGI(\"Device freg is open.\"); //将freg_device_t 接口转换为整型句柄值值返回 return (jint)device; } LOGE(\"Failed to open device freg.\"); return 0; } LOGE(\"Failed to get HAL stub freg.\"); return 0; } //java本地接口方法表 // 把JNI方法表method_table注册到Java虚拟机 static const JNINativeMethod method_table[] = { {\"init_native\", \"()I\", (void*)freg_init}, {\"setVal_native\", \"(II)V\", (void*)freg_setVal}, {\"getVal_native\", \"(I)I\", (void*)freg_getVal}, }; //注册java本地接口方法 int register_android_server_FregService(JNIEnv *env) { return jniRegisterNativeMethods(env, \"com/android/server/FregService\", method_table, NELEM(method_table)); } }; // frameworks/base/services/jni/onload.cpp #include \"JNIHelp.h\" #include \"jni.h\" #include \"utils/Log.h\" #include \"utils/misc.h\" namespace android { // ... int register_android_server_location_GpsLocationProvider(JNIEnv* env); // 声明 int register_android_server_FregService(JNIEnv* env); }; using namespace android; extern \"C\" jint JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; jint result = -1; if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) { LOGE(\"GetEnv failed!\"); return result; } LOG_ASSERT(env, \"Could not retrieve the env!\"); //... register_android_server_location_GpsLocationProvider(env); //调用 register_android_server_FregService(env); return JNI_VERSION_1_4; } # frameworks/base/services/jni/Android.mk LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) # 修改变量LOCAL_SRC_FILES的值 LOCAL_SRC_FILES:= \\ #... com_android_server_location_GpsLocationProvider.cpp \\ com_android_server_FregService.cpp \\ onload.cpp LOCAL_C_INCLUDES += \\ $(JNI_H_INCLUDE) LOCAL_SHARED_LIBRARIES := \\ libandroid_runtime \\ libcutils \\ libhardware \\ libhardware_legacy \\ libnativehelper \\ libsystem_server \\ libutils \\ libui \\ libsurfaceflinger_client ifeq ($(TARGET_SIMULATOR),true) ifeq ($(TARGET_OS),linux) ifeq ($(TARGET_ARCH),x86) LOCAL_LDLIBS += -lpthread -ldl -lrt endif endif endif ifeq ($(WITH_MALLOC_LEAK_CHECK),true) LOCAL_CFLAGS += -DMALLOC_LEAK_CHECK endif LOCAL_MODULE:= libandroid_servers include $(BUILD_SHARED_LIBRARY) # 重新编译libandroid_servers模块 , 得到的libandroid_servers.so文件 mmm ./frameworks/base/services/jni/ 启动硬件访问服务 //... class ServerThread extends Thread { //... // 修改 ServerThread 类的成员函数run的实现 @Override public void run() { //... if (factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) { //... try { Slog.i(TAG, \"DiskStats Service\"); ServiceManager.addService(\"diskstats\", new DiskStatsService(context)); } catch (Throwable e) { Slog.e(TAG, \"Failure starting DiskStats Service\", e); } try { Slog.i(TAG, \"Freg Service\"); ServiceManager.addService(\"freg\", new FregService()); } catch (Throwable e) { Slog.e(TAG, \"Failure starting Freg Service\", e); } } //... } } //... # 重新编译services模块 mmm ./frameworks/base/services/java/ # 重新打包Android系统镜像文件system.img make snod 开发Android应用程序来使用硬件访问服务 ~/Android/packages/experimental/Freg # 配置文件 AndroidManifest.xml Android.mk # 源代码目录 src shy/luo/freg Freg.java # 资源目录res res layout main.xml values string.xml drawable icon.png Freg.java : // Android\\packages\\experimental\\Freg\\src\\shy\\luo\\freg public class Freg extends Activity implements OnClickListener { private final static String LOG_TAG = \"shy.luo.freg.FregActivity\"; private IFregService fregService = null; private EditText valueText = null; private Button readButton = null; private Button writeButton = null; private Button clearButton = null; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); fregService = IFregService.Stub.asInterface(ServiceManager.getService(\"freg\")); valueText = (EditText)findViewById(R.id.edit_value); readButton = (Button)findViewById(R.id.button_read); writeButton = (Button)findViewById(R.id.button_write); clearButton = (Button)findViewById(R.id.button_clear); readButton.setOnClickListener(this); writeButton.setOnClickListener(this); clearButton.setOnClickListener(this); Log.i(LOG_TAG, \"Freg Activity Created\"); } @Override public void onClick(View v) { if(v.equals(readButton)) { try { int val = fregService.getVal(); String text = String.valueOf(val); valueText.setText(text); } catch (RemoteException e) { Log.e(LOG_TAG, \"Remote Exception while reading value from freg service.\"); } } else if(v.equals(writeButton)) { try { String text = valueText.getText().toString(); int val = Integer.parseInt(text); fregService.setVal(val); } catch (RemoteException e) { Log.e(LOG_TAG, \"Remote Exception while writing value to freg service.\"); } } else if(v.equals(clearButton)) { String text = \"\"; valueText.setText(text); } } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-14 15:27:16 "},"android_bottom/smart_pointer.html":{"url":"android_bottom/smart_pointer.html","title":"智能指针","keywords":"","body":" 智能指针 @Author: cpu_code @Date: 2020-07-12 14:09:20 @LastEditTime: 2020-07-13 11:48:21 @FilePath: \\note\\android_bottom\\smart_pointer.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ 在Android系统的应用程序框架层中， 有一部分代码是使用C++语言开发 . 用C++最容易出错的地方就是指针， 一般为忘记释放指针指向的对象所占用的内存， 或者使用了无效指针。 C++指针使用不当， 轻则造成内存泄漏， 重则造成莫名其妙的逻辑错误， 甚至系统崩溃。 因此， Android系统为我们提供了C++智能指针， 避免出现指针使用不当的问题 为了解决以上问题 , 通常通过引用计数技术来维护对象的生命周期 每当有一个新的指针指向了一个对象时， 这个对象的引用计数就增加1 ; 每当有一个指针不再指向一个对象时， 这个对象的引用计数就减少1 ; 当对象的引用计数为0时， 它所占用的内存就可以安全地释放了 . 智能指针正是一种能够自动维护对象引用计数的技术。 这里需要特别强调的是， 智能指针是一个对象， 而不是一个指针， 但是它引用了一个实际使用的对象。 在智能指针构造时， 增加它所引用的对象的引用计数； 而在智能指针析构时， 就减少它所引用的对象的引用计数 . 当 有两个对象A和B， 对象A引用了对象B， 而对象B也引用了对象A。 一方面， 当对象A不再使用时， 就可以释放它所占用的内存了， 但是由于对象B仍然在引用着它， 因此， 此时对象A就不能被释放； 另一方面， 当对象B不再使用时， 就可以释放它所占用的内存了， 但是由于对象A仍然在引用着它， 因此， 此时对象B也不能被释放 这个问题也是 垃圾收集(Garbage Collection)系统所遇到的经典问题之一， 因为它一次只能收集一个对象所占用的内存。 为了解决以上问题 , 采取另外一种稍为复杂的引用计数技术来维护对象的生命周期了。 这种引用计数技术将对象的引用计数分为强引用计数和弱引用计数两种， 其中， 对象的生命周期只受强引用计数控制。 在“父-子”关系中， “父”对象通过强引用计数来引用“子”对象； “子”对象通过弱引用计数来引用“父”对象。 假设对象A为 父 , 对象B为子。 对象A通过强引用计数来引用对象B， 而对象B通过弱智能指针引用计数来引用对象A。 当对象A不再使用时， 对象A的生命周期不受对象B的影响， 此时对象A可以安全地释放。 在释放对象A时， 同时也会释放它对对象B的强引用计数， 因此， 当对象B不再使用时， 对象B也可以安全地释放了。 Android系统提供了三种类型的C++智能指针， 分别为轻量级指针(Light Pointer)、 强指针(StrongPointer)和弱指针(Weak Pointer)， 其中， 轻量级指针使用了简单的引用计数技术， 而强指针和弱指针使用了强引用计数和弱引用计数技术 Android系统将引用计数器定义为一个公共类， 所有支持使用智能指针的对象类都必须要从这个公共类继承下来。 这样， Android系统的智能指针就可以通过这个引用计数器来维护对象的生命周期了 轻量级指针 轻量级指针通过简单的引用计数技术来维护对象的生命周期。如果一个类的对象支持使用轻量级指针，那么它就必须要从LightRefBase类继承下来，因为LightRefBase类提供了一个简单的引用计数器。 实现原理分析 分析LightRefBase类的实现原理 // frameworks\\base\\include\\utils\\RefBase.h // 模板类 // T 表示对象的实际类型，它必须是继承了LightRefBase类的 template class LightRefBase { public: inline LightRefBase() : mCount(0) { } // 增加它所引用的对象的引用计数 inline void incStrong(const void* id) const { android_atomic_inc(&mCount); } //减少它所引用的对象的引用计数 inline void decStrong(const void* id) const { if (android_atomic_dec(&mCount) == 1) { //释放这个对象所占用的内存 delete static_cast(this); } } //! DEBUGGING ONLY: Get current strong ref count. inline int32_t getStrongCount() const { return mCount; } protected: inline ~LightRefBase() { } private: mutable volatile int32_t mCount; // 描述一个对象的引用计数值 }; 轻量级指针的实现类为sp，它同时也是强指针的实现类 : // frameworks\\base\\include\\utils\\RefBase.h // 模块类，其中，模板参数T表示对象的实际类型，它也是必须继承了LightRefBase类的 template class sp { public: // 维护它所引用的对象的强引用计数和弱引用计数 typedef typename RefBase::weakref_type weakref_type; // m_ptr 在构造函数里面初始化的，指向实际引用的对象 inline sp() : m_ptr(0) { } sp(T* other); sp(const sp& other); template sp(U* other); template sp(const sp& other); ~sp(); // Assignment sp& operator = (T* other); sp& operator = (const sp& other); template sp& operator = (const sp& other); template sp& operator = (U* other); //! Special optimization for use by ProcessState (and nobody else). void force_set(T* other); // Reset void clear(); // Accessors inline T& operator* () const { return *m_ptr; } inline T* operator-> () const { return m_ptr; } inline T* get() const { return m_ptr; } // Operators COMPARE(==) COMPARE(!=) COMPARE(>) COMPARE(=) private: template friend class sp; template friend class wp; // Optimization for wp::promote(). sp(T* p, weakref_type* refs); T* m_ptr; }; sp类的构造函数有两个版本，一个是普通的构造函数，一个是拷贝构造函数 : // frameworks\\base\\include\\utils\\RefBase.h /* 由于成员变量m_ptr所指向的对象是从LightRefBase类继承下来的， 因此，这两个构造函数实际上是调用了LightRefBase类的成员函数incStrong来增加对象的引用计数。 */ // 首先初始化成员变量m_ptr template sp::sp(T* other) : m_ptr(other) { if (other) { // 调用它的成员函数incStrong来增加它的引用计数 other->incStrong(this); } } // 首先初始化成员变量m_ptr template sp::sp(const sp& other) : m_ptr(other.m_ptr) { if (m_ptr) { // 调用它的成员函数incStrong来增加它的引用计数 m_ptr->incStrong(this); } } sp类的析构函数的实现 : // frameworks\\base\\include\\utils\\RefBase.h /* 析构函数执行的操作刚好与构造函数相反，即调用成员变量m_ptr所指向的对象的成员函数decStrong来减少它的引用计数， 实际上是调用LightRefBase类的成员函数decStrong来减少对象的引用计数 */ template sp::~sp() { if (m_ptr) { // 调用成员函数decStrong来减少它的引用计数 m_ptr->decStrong(this); } } 应用实例分析 在external目录中建立一个C++应用程序lightpointer来说明轻量级指针的使用方法，它的目录结构如下： ~/Android external lightpointer lightpointer.cpp Android.mk 应用程序lightpointer的实现，它只有一个源文件lightpointer.cpp和一个编译脚本文件Android.mk lightpointer.cpp : #include #include using namespace android; // 继承了LightRefBase类的LightClass类 , 能够结合轻量级指针来使用 class LightClass : public LightRefBase { public: LightClass() { printf(\"Construct LightClass Object.\\n\"); } virtual ~LightClass() { printf(\"Destory LightClass Object.\\n\"); } }; // lightpointer 的入口函数 main int main(int argc, char** argv) { // 创建了一个 LightClass 对象 pLightClass LightClass* pLightClass = new LightClass(); // 创建一个轻量级指针 lpOut 来引用它 // 创建过程中, 调用 sp 类的构造函数来增加 LightClass 对象 pLightClass 的引用计数， // 即此时 LightClass 对象 pLightClass 的引用计数值为 1 sp lpOut = pLightClass; // 打印 == 1 printf(\"Light Ref Count: %d.\\n\", pLightClass->getStrongCount()); //内嵌的作用域 { /* * 创建了另外一个轻量级指针 lpInner 来引用 LightClass 对象 pLightClass * LightClass 对象 pLightClass 的引用计数值会再增加1 */ sp lpInner = lpOut; // printf语句打印出来的数字就应该等于2 printf(\"Light Ref Count: %d.\\n\", pLightClass->getStrongCount()); } /* * 当应用程序 lightpointer 跳出了作用域之后，轻量级指针 lpInner 就被析构了， *这时候 LightClass 对象 pLightClass 的引用计数值就会减少 1 */ //打印 == 1 printf(\"Light Ref Count: %d.\\n\", pLightClass->getStrongCount()); /* *当应用程序 lightpointer 执行完成之后，轻量级指针 lpOut 也会被析构， *这时 LightClass 对象 pLightClass 的引用计数值就会再次减少 1，== 0，于是LightClass对象pLightClass就会被释放 */ return 0; } Android.mk 应用程序lightpointer的编译脚本文件，它引用了libcutils和 libutils两个库 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_MODULE := lightpointer LOCAL_SRC_FILES := lightpointer.cpp LOCAL_SHARED_LIBRARIES := \\ libcutils \\ libutils include $(BUILD_EXECUTABLE) 对这个C++工程进行编译和打包 mmm ./external/lightpointer/ make snod 编译成功之后，就可以在 out/target/product/gerneric/system/bin 目录下看到应用程序文件lightpointer了； 打包成功之后，该应用程序就包含在out/target/product/gerneric目录下的Android系统镜像文件system.img中了。 # 使用新得到的系统镜像文件 system.img 来启动 Android 模拟器 emulator & # 使用adb工具连接上它 adb shell # 进入到/system/bin 目录中 cd system/bin/ # 运行应用程序 lightpointer 来查看它的输出 ./lightpointer 如果能看到上面的输出，就说明我们前面对轻量级指针的实现原理的分析是正确的。 强指针和弱指针 强指针和弱指针通过强引用计数和弱引用计数来维护对象的生命周期。 如果一个类的对象要支持使用强指针和弱指针，那么它就必须从RefBase类继承下来，因为RefBase类提供了强引用计数器和弱引用计数器。 强指针的实现原理分析 分析RefBase类的实现原理 : // frameworks\\base\\include\\utils\\RefBase.h class RefBase { public: // 成员函数 incStrong 和 decStrong 来维护它所引用的对象的引用计数 void incStrong(const void* id) const; void decStrong(const void* id) const; void forceIncStrong(const void* id) const; //! DEBUGGING ONLY: Get current strong ref count. int32_t getStrongCount() const; class weakref_type { public: RefBase* refBase() const; void incWeak(const void* id); void decWeak(const void* id); bool attemptIncStrong(const void* id); //! This is only safe if you have set OBJECT_LIFETIME_FOREVER. bool attemptIncWeak(const void* id); //! DEBUGGING ONLY: Get current weak ref count. int32_t getWeakCount() const; //! DEBUGGING ONLY: Print references held on object. void printRefs() const; //! DEBUGGING ONLY: Enable tracking for this object. // enable -- enable/disable tracking // retain -- when tracking is enable, if true, then we save a stack trace // for each reference and dereference; when retain == false, we // match up references and dereferences and keep only the // outstanding ones. void trackMe(bool enable, bool retain); }; weakref_type* createWeak(const void* id) const; weakref_type* getWeakRefs() const; //! DEBUGGING ONLY: Print references held on object. inline void printRefs() const { getWeakRefs()->printRefs(); } //! DEBUGGING ONLY: Enable tracking of object. inline void trackMe(bool enable, bool retain) { getWeakRefs()->trackMe(enable, retain); } protected: RefBase(); virtual ~RefBase(); //! Flags for extendObjectLifetime() enum { OBJECT_LIFETIME_WEAK = 0x0001, OBJECT_LIFETIME_FOREVER = 0x0003 }; void extendObjectLifetime(int32_t mode); //! Flags for onIncStrongAttempted() enum { FIRST_INC_STRONG = 0x0001 }; virtual void onFirstRef(); virtual void onLastStrongRef(const void* id); virtual bool onIncStrongAttempted(uint32_t flags, const void* id); virtual void onLastWeakRef(const void* id); private: friend class weakref_type; class weakref_impl; RefBase(const RefBase& o); RefBase& operator=(const RefBase& o); //使用一个weakref_impl对象，即成员变量 mRefs 来描述对象的引用计数 weakref_impl* const mRefs; }; weakref_impl类同时为对象提供了强引用计数和弱引用计数 : // frameworks\\base\\libs\\utils\\RefBase.cpp /* weakref_type 类定义在RefBase类的内部，它提供了成员函数 incWeak、decWeak、attemptIncStrong 和 attemptIncWeak 来 维护对象的强引用计数和弱引用计数 . weakref_type 类只定义了引用计数维护接口，具体的实现是由 weakref_impl 类提供的 */ // weakref_impl类继承了weakref_type类 class RefBase::weakref_impl : public RefBase::weakref_type { public: volatile int32_t mStrong; // 对象的强引用计数 volatile int32_t mWeak; // 弱引用计数 RefBase* const mBase; // 指向了它所引用的对象的地址 /* * 一个标志值，用来描述对象的生命周期控制方式 * 取值范围为0、OBJECT_LIFETIME_WEAK 或者 OBJECT_LIFETIME_FOREVER * 0 : 对象的生命周期只受强引用计数影响 * OBJECT_LIFETIME_WEAK : 对象的生命周期同时受强引用计数和弱引用计数影响； * OBJECT_LIFETIME_FOREVER : 对象的生命周期完全不受强引用计数或者弱引用计数影响 */ volatile int32_t mFlags; // 类的实现有调试和非调试两个版本 #if !DEBUG_REFS // 被编译成非调试版本 // 成员变量mStrong的值被初始化为 INITIAL_STRONG_VALUE == 1 RefBase、weakref_type和weakref_impl类的关系 : 每一个RefBase对象都包含了一个weakref_impl对象， 而后者继承了weakref_type类 强指针的实现类为sp， sp类的构造函数的实现 : // frameworks\\base\\include\\utils\\RefBase.h // 模块参数 T 是一个继承了 RefBase 类的子类 template sp::sp(T* other) : m_ptr(other) { // 调用了 RefBase 类的成员函数 incStrong 来增加对象的强引用计数 if (other) { other->incStrong(this); } } // frameworks\\base\\libs\\utils\\RefBase.cpp // RefBase 类的成员函数 incStrong实现 void RefBase::incStrong(const void* id) const { weakref_impl* const refs = mRefs; refs->addWeakRef(id); // 增加对象的弱引用计数 refs->incWeak(id); refs->addStrongRef(id); // 增加对象的强引用计数 , 增加RefBase类的引用计数对象mRefs的成员变量mStrong的值 // 返回值是对象原来的强引用计数值， 即加1前的值 const int32_t c = android_atomic_inc(&refs->mStrong); LOG_ASSERT(c > 0, \"incStrong() called on %p after last strong ref\", refs); #if PRINT_REFS LOGD(\"incStrong of %p from %p: cnt=%d\\n\", this, id, c); #endif if (c != INITIAL_STRONG_VALUE) { return; } // 将RefBase类的成员函数incStrong需要将它调整为1 android_atomic_add(-INITIAL_STRONG_VALUE, &refs->mStrong); /* *调用对象的成员函数 onFirstRef 来通知对象， 它被强指针引用了 * RefBase 类的成员函数 onFirstRef 是一个空实现， * 如果子类想要处理这个事件， 那么就必须要重写成员函数 onFirstRef */ const_cast(this)->onFirstRef(); } // frameworks\\base\\libs\\utils\\RefBase.cpp #define INITIAL_STRONG_VALUE (1 // frameworks\\base\\libs\\utils\\RefBase.cpp // RefBase类的成员变量mRefs是在构造函数中初始化 RefBase::RefBase() : mRefs(new weakref_impl(this)) { // LOGV(\"Creating refs %p with RefBase %p\\n\", mRefs, this); } // frameworks\\base\\libs\\utils\\RefBase.cpp // 调用 weakref_type 类的成员函数 incWeak 来增加对象的弱引用计数 void RefBase::weakref_type::incWeak(const void* id) { // this指针指向的实际上是一个weakref_impl对象 // 将它转换为一个weakref_impl指针 impl weakref_impl* const impl = static_cast(this); impl->addWeakRef(id); // 增加它的成员变量mWeak的值， 即增加对象的弱引用计数 const int32_t c = android_atomic_inc(&impl->mWeak); // 调用是与调试相关的 LOG_ASSERT(c >= 0, \"incWeak called on %p after last weak ref\", this); } 强指针类sp的构造函数的实现 , 主要做的事情就是增加对象的强引用计数和弱引用计数。 从这里就可以看出， 虽然我们的目的是增加对象的强引用计数，但是同时也会增加对象的弱引用计数， 即一个对象的弱引用计数一定是大于或 等于它的强引用计数的。 sp类的析构函数的实现 : // frameworks\\base\\include\\utils\\RefBase.h // sp类的成员变量m_ptr所指向的对象是继承了RefBase类 template sp::~sp() { if (m_ptr) { // 调用了RefBase类的成员函数decStrong来减少对象的强引用计数 m_ptr->decStrong(this); } } // frameworks\\base\\libs\\utils\\RefBase.cpp // 析构函数 , 减少对象的强引用计数和弱引用计数 void RefBase::decStrong(const void* id) const { weakref_impl* const refs = mRefs; // 非调试版本中是空函数调用 refs->removeStrongRef(id); // 减少对象的强引用计数 // 返回值是对象原来的强引用计数值，即减1前的值， 保存在变量c中 const int32_t c = android_atomic_dec(&refs->mStrong); #if PRINT_REFS LOGD(\"decStrong of %p from %p: cnt=%d\\n\", this, id, c); #endif LOG_ASSERT(c >= 1, \"decStrong() called on %p too many times\", refs); // 如果变量c的值等于1， 就说明此时再也没有强指针引用这个对象了 if (c == 1) { // 调用该对象的成员函数 onLastStrongRef 执行一些业务相关的逻辑 const_cast(this)->onLastStrongRef(id); // 考虑是否需要释放该对象 // 检查对象的生命周期是否受弱引用计数控制， //即 RefBase 类的成员变量 mRefs 的标志值 mFlags 的 OBJECT_LIFETIME_WEAK 位是否等于1 // 不等于1， 就说明对象的生命周期不受弱引用计数影响 if( (refs->mFlags & OBJECT_LIFETIME_WEAK) != OBJECT_LIFETIME_WEAK) { // 释放对象所占用的内存， 这同时会导致RefBase类的析构函数被调用 delete this; } } // 非调试版本中是空函数调用 refs->removeWeakRef(id); /* * 减少对象的弱引用计数的操作 * 变量 refs 指向的是 RefBase 类内部的 weakref_impl 对象 mRefs。 * weakref_impl 类的成员函数 decWeak 是从父类 weakref_type 继承下来的， * 因此， 接下来实际执行的是 weakref_type 类的成员函数 decWeak */ refs->decWeak(id); } // frameworks\\base\\libs\\utils\\RefBase.cpp // RefBase类的析构函数 RefBase::~RefBase() { // LOGV(\"Destroying RefBase %p (refs %p)\\n\", this, mRefs); /* * 对象的弱引用计数值 == 0 * RefBase 类的成员变量 mRefs 指向的是一个 weakref_impl 对象， 它是在 RefBase 类的构造函数中创建的。 * 它所属的RefBase对象已经不存在了，而且它所引用的对象的弱引用计数值 == 0， 它也就不需要存在了 */ if (mRefs->mWeak == 0) { // LOGV(\"Freeing refs %p of old RefBase %p\\n\", mRefs, this); // 把引用计数对象mRefs也一起释放 delete mRefs; } /* * 在对象的弱引用计数值 > 0的情况下， 我们只能将对应的 RefBase 对象释放掉， * 而不能将该 RefBase 对象内部的 weakref_impl 对象也释放掉 */ } // frameworks\\base\\libs\\utils\\RefBase.cpp // weakref_type 类的成员函数 decWeak void RefBase::weakref_type::decWeak(const void* id) { weakref_impl* const impl = static_cast(this); // 非调试版本中是空函数调用 impl->removeWeakRef(id); // 减少对象的弱引用计数， 并且返回减少之前的值， 保存在变量c中 const int32_t c = android_atomic_dec(&impl->mWeak); LOG_ASSERT(c >= 1, \"decWeak called on %p too many times\", this); if (c != 1) { // 说明还有其他的弱指针在引用这个对象，那就不用进一步处理了 return; } // c == 1， 那么就说明再也没有弱指针引用这个对象了， 同时也说明没有强指针引用这个对象 // 当对象的弱引用计数值 == 0 时， 它的强引用计数值也一定 == 0 // 在对象的弱引用计数值 == 0 时， 我们就要考虑是否需要将该对象释放掉。 // 这取决于对象的生命周期控制方式， 以及该对象是否被强指针引用过。 if ((impl->mFlags & OBJECT_LIFETIME_WEAK) != OBJECT_LIFETIME_WEAK) { // 对象的生命周期只受强引用计数控制 if (impl->mStrong == INITIAL_STRONG_VALUE) { // 对象从来没有被强指针引用过， 那么在该对象的弱引用计数值 == 0时 // 将该对象释放掉 delete impl->mBase; } else { // LOGV(\"Freeing refs %p of old RefBase %p\\n\", this, impl->mBase); // 只释放其内部的引用计数器对象 weakref_impl delete impl; } } else { // 对象的生命周期受弱引用计数控制 // 调用对象的成员函数 onLastWeakRef 执行一些业务相关的逻辑 impl->mBase->onLastWeakRef(id); /* * 检查对象的生命周期是否完全不受强引用计数和弱引用计数控制， * 即 RefBase 类的成员变量 mRefs 的标志值 mFlags 的OBJECT_LIFETIME_FOREVER位是否 == 1 */ if ((impl->mFlags & OBJECT_LIFETIME_FOREVER) != OBJECT_LIFETIME_FOREVER) { // != 1，释放对象所占用的内存 delete impl->mBase; } } } 对对象的生命周期控制方式作一个小结 : 如果一个对象的生命周期控制标志值 == 0， 那么只要它的强引用计数值 == 0， 系统就会自动释放这个对象 如果一个对象的生命周期控制标志值 == OBJECT_LIFETIME_WEAK， 那么只有当它的强引用计数值 和 弱引用计数值都 == 0， 系统才会自动释放这个对象。 如果一个对象的生命周期控制标志值被设置为 OBJECT_LIFETIME_FOREVER， 那么系统就永远不会自动释放这个对象， 它需要由开发人员来手动地释放。 弱指针的实现原理分析 如果一个类的对象支持使用弱指针， 那么这个类就必须要从RefBase类继承下来， 因为RefBase类提供了弱引用计数器。 弱指针类wp的实现 : // frameworks\\base\\include\\utils\\RefBase.h // wp类是一个模块类， 模板参数T表示对象的实际类型， 它必须是从RefBase类继承下来的 template class wp { public: typedef typename RefBase::weakref_type weakref_type; inline wp() : m_ptr(0) { } wp(T* other); wp(const wp& other); wp(const sp& other); template wp(U* other); template wp(const sp& other); template wp(const wp& other); ~wp(); // Assignment wp& operator = (T* other); wp& operator = (const wp& other); wp& operator = (const sp& other); template wp& operator = (U* other); template wp& operator = (const wp& other); template wp& operator = (const sp& other); void set_object_and_refs(T* other, weakref_type* refs); // promotion to sp // 将这个弱指针升级为强指针 // 升级成功，就说明该弱指针所引用的对象还没有被销毁， 可以正常使用 sp promote() const; // Reset void clear(); // Accessors inline weakref_type* get_refs() const { return m_refs; } inline T* unsafe_get() const { return m_ptr; } // Operators COMPARE_WEAK(==) COMPARE_WEAK(!=) COMPARE_WEAK(>) COMPARE_WEAK(=) inline bool operator == (const wp& o) const { return (m_ptr == o.m_ptr) && (m_refs == o.m_refs); } template inline bool operator == (const wp& o) const { return m_ptr == o.m_ptr; } inline bool operator > (const wp& o) const { return (m_ptr == o.m_ptr) ? (m_refs > o.m_refs) : (m_ptr > o.m_ptr); } template inline bool operator > (const wp& o) const { return (m_ptr == o.m_ptr) ? (m_refs > o.m_refs) : (m_ptr > o.m_ptr); } inline bool operator & o) const { return (m_ptr == o.m_ptr) ? (m_refs inline bool operator & o) const { return (m_ptr == o.m_ptr) ? (m_refs & o) const { return m_refs != o.m_refs; } template inline bool operator != (const wp& o) const { return !operator == (o); } inline bool operator & o) const { return !operator > (o); } template inline bool operator & o) const { return !operator > (o); } inline bool operator >= (const wp& o) const { return !operator inline bool operator >= (const wp& o) const { return !operator friend class sp; template friend class wp; // 指向它所引用的对象 T* m_ptr; // 维护对象的弱引用计数 weakref_type* m_refs; }; wp类的构造函数的实现 : // frameworks\\base\\include\\utils\\RefBase.h // 模块参数T是一个继承了RefBase类的子类 template wp::wp(T* other) : m_ptr(other) { if (other) { // 调用 RefBase 类的成员函数 createWeak 来增加对象的弱引用计数 m_refs = other->createWeak(this); } } // frameworks\\base\\libs\\utils\\RefBase.cpp // 将它的成员变量mRefs所指向的一个 weakref_impl 对象返回给调用者 RefBase::weakref_type* RefBase::createWeak(const void* id) const { // RefBase类的成员变量 mRefs 指向的是一个 weakref_impl 对象 // 加实际引用对象的弱引用计数 mRefs->incWeak(id); return mRefs; } wp类的析构函数的实现 : 应用实例分析 在external目录下建立一个C++应用程序weightpointer来说明强指针和弱指针的使用方法 目录结构 : ~/Android external weightpointer weightpointer.cpp Android.mk Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-13 21:18:00 "},"android_bottom/AOSP.html":{"url":"android_bottom/AOSP.html","title":"AOSP源码开发","keywords":"","body":" AOSP源码开发 @Author: cpu_code @Date: 2020-07-11 16:18:27 @LastEditTime: 2020-07-12 21:08:41 @FilePath: \\note\\android_bottom\\summary.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ android源码之前分为四层 : 新的android源码分为五层， 增加了HAL层 : 　源码级开发（ 系统开发） 源码级开发就是基于AOSP（ Android Open Source Project） 环境的开发工作， 主要开发场景为Android系统定制， 比如手机设备的MIUI, Flyme， Smartisan OS, 基于电视的LetvUI， 甚至还有针对投影仪， 路由器等传统物联设备的Android系统定制开发。 Android系统分层 HAL层： （ Hardware Abstract Layer） 硬件抽象层。 Android系统里封装内核驱动程序的接口层。 对上层提供接口， 屏蔽底层驱动实现细节. 为了摆脱 GNU License（ 开源感染性） ，Google将Linux内核中跟底层硬件操作相关的逻辑封装成HAL层接口， 厂商基于接口去实现， 不直接在内核空间实现驱动。 因为Android系统遵循 Apache License， 不强制开源。 三方应用开发与源码级开发的区别 三方应用开发是基于Android SDK开发。 主要技术方向为APP及混合APP开发， 数据库， 网络协议， 应用架构等， 服务于商业APP需求。 源码级开发是基于AOSP环境开发， 主要技术方向为系统应用开发， Framework开发， 底层浏览器内核开发， 音视频编解码开发， 虚拟机开发， 底层驱动开发等。 服务于系统定制需求。 AOSP官网 AOSP官网提供系统开发相关指导， 比如源码的环境搭建， 下载， 编译， 维护， 更新版本， 开放驱动的下载等 https://source.android.google.cn/ Ubuntu系统安装与介绍 AOSP环境要求操作系统为Linux或者Mac OS。 如果想在Window下进行AOSP开发， 通过通过虚拟机软件安装一个Linux系统， 比如Ubuntu或CentOS。 安装虚拟机 VirtualBox , VMWare Ubuntu系统的安装与介绍 Ubuntu系统是开发使用比较广泛的一个Linux发行版 , 带LTS（ Long Term Support） ， 代表是官方长期维护的版本 常见Linux命令 Linux命令是对Linux系统进行管理的命令。 对于Linux系统来说， 无论是中央处理器、 内存、磁盘驱动器、 键盘、 鼠标， 还是用户等都是文件。 命令就是去操作文件， 以达到管理系统的目的。 Linux包含系统内置shell命令（ 如 cd） 及安装的其他Linux命令（ 如 git） 。 相比Window系统的强项-图形化， Linux的命令则是它的强项。 熟练掌握常见Linux命令， 是做Linux环境下开发的基本技能。 PS： Linux命令大部分在Mac OS 下也是通用的， 它们都属于类Unix系统。 目录操作 # 获取当前目录路径 pwd # 查看文件列表 eg: ls dirname ls # 查看所有文件， 包括隐藏文件 -a # 查看文件详细信息 -l # 代表当前目录 . # 代表上一级目录 .. # 进入某一个目录 eg: cd dirname cd # 进入上一级目录 cd .. # 进入上次所在目录 cd - # 创建目录 mkdir # 创建多级目录 -p # 拷贝文件或者目录 eg: cp src1 src2... dest cp # 拷贝目录 eg: cp -r src dest -r # 移动文件或者目录 eg:mv src dest (如果srcfile和destfile在同一目录下， 就是重命名的效果) mv # 删除文件 eg: rm filename1 filename2 ... rm # 删除目录 eg: rm -r dirname -r 文件查找 # 查找某一个文件， find [path] -name find # 从某一个文件/目录下所有文件 中匹配字符串， grep [-r -n ] path grep # 遍历目录查找 -r # 显示行号 -n 系统操作 # 切换到某一个用户(需要输入要切换的用户的密码) eg: su username su # 非root用户强制执行一些需要root权限的操作(需要输入当前用户的密码) eg: sudo rm filename sudo # Ubuntu的软件管家， 进行软件的更新， 卸载与维护。 apt-get # 终端下的文本编辑器。 vim # 进入编辑模式 i # 跳到命令模式 ESC # 删除一行 dd # 保存退出 :wq # 不保存退出 :q! # 查看文件,将文本内容打印到控制台。 cat vim # 安装VIM sudo apt-get install vim # 卸载VIM sudo apt-get remove vim # 更新到最新软件列表 sudo apt-get update chmod # 修改文件权限， eg： chmod a+x xxx.sh chmod 777 xxx.sh # 权限设定可以使用字串[ugoa][+-=][rwx]或者数字 (r=4,w=2,x=1,-=0)， # u 拥有者 # g 用户组 # o 其他用户 # a 所有人 # + 表示增加权限 # - 表示取消权限 # = 表示直接指定权限 chmod AOSP源码工作环境 源码工作环境， 就是安装所依赖的一些软件库， 以及开发调试时需要进行的一些配置。 主要分为编译环境准备， AOSP源码下载， 源码预编译等。 这里主要介绍在Ubuntu14.04 LTS下开发Android6.0代码的工作环境准备。 编译环境搭建（ Ubuntu14.04） JDK和依赖包下载 #获取源的更新 sudo apt-get update #下载openjdk7 sudo apt-get install openjdk-7-jdk sunjdk 采用Java研究许可（ Java Research License， 简称JRL） 许可证书， 部分开源， 仅限研究。 openjdk采用GNU许可证书， 完全开源。 sunjdk中私有APIs用类似功能的开源代码替换/重新实现。 安装其他依赖 sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g -dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx 11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip USB设备权限配置 以root身份在/etc/udev/rules.d/ 目录下创建一个rules规则文件， AOSP提供的rules里配置了常见Android设备 # 下载并配置AOSP的usb设备权限规则模板 wget -S -O - [http://source.android.com/source/51-android.rules](http://source.andro id.com/source/51-android.rules) | sed \"s//$USER/\" | sudo tee >/dev/null /etc /udev/rules.d/51-android.rules; sudo udevadm control --reload-rules 执行adb devices的时候可能会提示permission denied， 原因就是因为自己的Android设备没有加入到这个配置文件当中 # 列出当前系统识别到的USB设备 lsusb 假设出现 Bus 001 Device 007: ID 0403:cb48 Future Technology Devices International, Ltd idVendor是0403, idProduct是cb48 51-android.rules SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0403\", ATTR{idProduct}==\"cb48\", MODE=\"0600\", OWNER=\"\" 源码下载与管理 源码预编译 知识扩展 AOSP常见的命令， 目录介绍 Android Build System入门 什么是makefile ABS的工作流程 AOSP下进行系统开发 Android的启动流程简述 修改系统APP代码 定制framework 进一步修改native层的代码 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:08:55 "},"android_bottom/summary.html":{"url":"android_bottom/summary.html","title":"Android底层软硬件结合开发概述","keywords":"","body":" Android底层软硬件结合开发概述 @Author: cpu_code @Date: 2020-07-11 16:18:27 @LastEditTime: 2020-07-12 21:08:41 @FilePath: \\note\\android_bottom\\summary.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ Android底层软硬件结合开发概述 Android是 个开源的智能移动平台 一个开源的智能移动平台， 任何 个厂商拿 一个厂商拿到 Android Source 都可以基于自己的硬件架构设计 移动设备。 硬件多样化 厂商自己的利益 软硬件结合开发的弊端？ 失去了Android应用的跨平台特性 由于不同厂商研发能力参差不齐，应用程序的稳定性及性能有所不同 分类 NDK开发: 从应用角度来开发软硬结合代码 适用于单个应用程序的底层结合需求 HAL硬件抽象层开发: 从整个系统框架需求角度来开发本地程序 适用于共享功能软硬结合代码 HAL 概念 HAL（ Hardware Abstract Layer）硬件抽象层是Google开发的Android系统里上层应用对底层硬件操作屏蔽的一个软件层次，说白了，就是上层的应用不用关心底层硬件具体是如何工作的，只要向上提供一个统一的接口即可，这种设计思想广泛的存在于当前的软件架构设计里。 HAL存在的原因 1、 并不是所有的硬件设备都有标准的 linux kernel 的接口。 2、 Kernel driver涉及到GPL的版权。某些设备制造商并不愿意公开硬件驱动，所以才通过HAL方式绕过GPL。 3、 针对某些硬件， Android有一些特殊的需求。 HAL简介及现状分析 现有HAL架构由 Patrick Brady (Google) 在2008G l oogle I/O演讲中提出， 从上面架构图我们知道，HAL 的目的是为了把 Android framework 与Linux kernel 完整「隔开」。让 Android 不至过度依赖 Linux kernel， 有点「kernel independent」的意思。 AL简介及现状分析 HAL 主要的实现储存于以下目录 libhardware_legacy/ ‐ 旧的架构、 采取链接库模块的观念进行 libhardware/ ‐ 新架构、调整为 HAL stub 的观念 旧的HAL 架构(libhardware_legacy) libhardware_legacy 作法，是传统的「module」方式，也就是将 *.so 文件当做「shared library」来使用，在runtime（JNI 部份） 以 direct functioncall 使用 HAL module。通过直接调用函数的方式，来操作驱动程序。 当然，应用程序也可以不需要通过 JNI 的方式进行， 直接加载 .so 库（dlopen）的做法调用.so 里的符号（symbol）也是 一种方式。 总而言之是没有经过封装，上层可以直接操作硬件。 新的HAL 架构(libhardware) 现在的 libhardware 架构，就有「stub」的味道了。 HAL stub 是一种代理人（proxy） 的概念， stub 虽然仍是以 *.so的形式存在，但 HAL 已经将 *.so 隐藏起来了。 Stub 向 HAL「提供」 操作函数（operations） ，而 runtime 则是向 HAL 取得特定模块（stub）的 operations，再 callback这些操作函数。 这种以 indirect function call 的架构，让HAL stub 变成是一种「包含」关系，即 HAL 里包含了许许多多的 stub（代理人） 。Runtime 只要说明「类型」，即module ID，就可以取得操作函数。 对于目前的HAL， 可以认为Android定义了HAL层结构框架，通过几个接口访问硬件从而统一了调用方式。 HAL_legacy和HAL的对比 HAL_legacy：旧式的HAL是一个模块，采用共享库形式，在编译时会调用到。 由于采用 function call 形式调用，因此可被多个进程使用，但会被 mapping 到多个进程空间中， 同时需要考虑代码能否安全重入的问题（thread safe）。 HAL： 新式的HAL采用 HAL module 和 HAL stub 结合形式，HAL stub不是一个share library，编译时上层只拥有访问HAL stub的函数指针， 并不需要HAL stub。 上层通过HAL module提供的统一接口获取并操作HAL stub，so文件只会被mapping到一个进程， 也不存在重复mapping和重入问题。 HAL_legacy和HAL的对比 Module 角色是被调用 , 在Android架构里面仅作为程序库(library)用途 Stub Stub又称为代理人(proxy) , 扮演操作供应者的概念(operations provider) HAL_legacy和HAL的对比 HAL stub的框架比较简单： 三个结构体、 两个常量、 一个函数 它的定义在： hardware/libhardware/include/hardware/hardware.h hardware/libhardware/hardware.c HAL Stub架构分析 /* 每个一个HAL Stub都通过 hw_module_t 来描述， 我们称之为一个Stub对象。你可以去“ 继承 ”这个 hw_module_t，然后扩展自己的属性，这个HAL Stub对象必须定义为一个固定的名字：HMI( Hardware Module Information ) ，每一个Stub对象里都封装了一个函数open，通过这个函数来打开这个硬件Stub设备，返回这个硬件对应的Operation interface。 */ struct hw_module_t; /* HAL Stub对象的open描述结构体， 它里面只有一个元素： open函数指针 */ struct hw_module_methods_t; ​ /* 由结构体hw_module_t可知，它的open函数返回一个硬件对应的Operation interface， 这个硬件的operation interface的描述由hw_device_t 结构体来描述 */ struct hw_device_t; // 这个就是HAL Stub对象固定的名字 #define HAL_MODULE_INFO_SYM HMI // 这个是以字符串的名字 #define HAL_MODULE_INFO_SYM_AS_STR \"HMI\" //这个函数是通过硬件名来获得硬件HAL Stub对象 int hw_get_module(const char *id, const struct hw_module_t **module); //注册一个Stub对象 const struct led_modulet_HAL_MODULE_INFO_SYM = { common: { tag: HARDWARE_MODULE_TAG, version_major: 1, version_minor: 0, id: LED_HARDWARE_MODULE_ID, name: \"led HAL Stub\", author: \"farsight\", methods: &led_module_methods, }, // 扩展属性放在这儿 } Android里的Jni调用机制 JVM 很好的解决java的可移植性问题，使得java软件可以在不同的硬件平台下运行，但是JVM不是万能的，毕竟它只是一个模拟环境，对于一些外围的硬件就很难模拟， JVM只是模拟了一部分的寄存器， 栈结构， JVM储存器，这些都是软件运行的基础硬件结构。 对于像android手机这样的平台， 有很多的外围设备在软件层是需要操作的，如wifi，蓝牙，触摸屏，重力感应，键盘等，如果直接通过java语言操作是很难实现的， JVM无法模拟这些硬件。 JNI( Java Native Interface )， 中文为JAVA本地调用。 从Java1.1开始，Java Native Interface( JNI )标准成为java平台的一部分，它允许Java代码 和 其他语言写的代码进行交互。 JNI一开始是为了本地已编译语言， 尤其是 C 和 C++ 而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用 java 与本地已编译的代码交互，通常会丧失平台可移植性。 但是， 有些些情况下这样做是可以接受的， 甚至是必须的，比如， 使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。 JNI标准至少保证本地代码能工作在任何Java虚拟机实现下。 Jni在 Java和C、 C++等语言之间建立了一个桥梁作用，因此， JNI首先要做的，就是统一两者间的数据类型。 所有其它引用类型，在JNI中都被定义为 jobject 类型，在C中都定义为 void*。 Java Language Type JNI Type boolean jboolean byte jbyte char jchar short jshort int jint long jlong float jfloat double jdouble Java中可以直接调用底层语言的函数或方法， Jni规定了Java调用底层语言的方法签名规范。 类型签名 Java 类型 类型签名 Java 类型 Z boolean [ [] B byte [I int[] C char [F float[] S short [B byte[] I int [C char[] J long [S short[] F float [D double[] D double [J long[] L fully-qualified-class（全限定的类） [Z boolean[] Android里的Jni调用机制 函数签名通常是以下结构： 返回值 fun(参数1，参数2，参数3） ; 其对应的Jni方法签名格式为： (参数1参数2参数3)返回值 注意： 函数名，在Jni中没有体现出来 参数列表相挨着， 中间没有逗号， 没有空格 返回值出现在（）后面 如果参数是引用类型， 那么参数应该为： L类型; HAL Led调用流程 /LedDemo/Led Service(java)/Led Service(Native)/Led HAL Stub1:创建服务对象>2:通过JNI初始化本地服务()3: 查找并得到HAL操作接口()4:返回device操作接口5:操作service提供的API()6: 通过JNI调用本地服务操作接口()7: 调用保存的devicer操作接口()8: 返回HAL操作结果9: 返回本地服务操作结果10: 返回框架服务操作结果/LedDemo/Led Service(java)/Led Service(Native)/Led HAL Stub /Led APP/Led Service(java)/Led Service(Native)/Led HAL Stub1:new LedService()2:system.loadLibrary()3: JNI_OnLoad()注册java方法与本地函数的映射关系4: _init()5: hw_get_module()6: Return module_t object7: callback module_t open interface()8: Return device_t operations9: LedService.set_on/set_off()10: _set_on, _set_off()11: devict_t->set_on/set_off()/Led APP/Led Service(java)/Led Service(Native)/Led HAL Stub Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:08:49 "},"operating_system/operat_mechanism.html":{"url":"operating_system/operat_mechanism.html","title":"操作系统的运行机制","keywords":"","body":" 操作系统的 运行机制 @Author: cpu_code @Date: 2020-07-11 17:13:30 @LastEditTime: 2020-07-12 21:10:06 @FilePath: \\note\\operating_system\\operat_mechanism.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ graph LR; 操作系统的运行机制 --> 俩种指令 --> 特权指令; 操作系统的运行机制 --> 俩种处理器状态 --> 核心态; 操作系统的运行机制 --> 俩种程序 --> 内核程序; 俩种指令 --> 非特权指令; 俩种处理器状态 --> 用户态; 俩种程序 --> 应用程序; 一条高级语言的代码翻译过来可能会对应多条机器指令 ： graph LR; C语言代码 --- 编译器:翻译 --> 机器指令:二进制; “ 指令 ” ：处理器（CPU） 能识别、 执行的最基本命令 程序运行的过程其实就是CPU执行一条一条的机器指令的过程 注： 很多人习惯把 Linux、 Windows、 MacOS 的 “ 小黑框 ” 中使用的命令也称为“ 指令 ” ， 其实这是“ 交互式命令接口 ” ， 注意与本节的 “ 指令 ” 区别开。 此 “ 指令 ” 指二进制机器指令 内核程序 & 应用程序 我们普通程序员写的程序就是“ 应用程序 ” 微软、 苹果有一帮人负责实现操作系统， 他们写的是“ 内核程序 ” 由很多内核程序组成了“ 操作系统内核 ” ， 或简称“ 内核（Kernel） ” 内核是操作系统最重要最核心的部分， 也是最接近硬件的部分甚至可以说， 一个操作系统只要有内核就够了（eg： Docker—>仅需Linux内核） 操作系统的功能未必都在内核中， 如图形化用户界面 GUI 特权指令 & 非特权指令 应用程序只能使用“ 非特权指令 ” ， 如：加法指令、 减法指令等 操作系统内核作为 “管理者” ， 有时会让CPU执行一些“特权指令” ， 如： 内存清零指令。 这些指令影响重大，只允许“ 管理者 ” —— 即操作系统内核来使用 在CPU设计和生产的时候就划分了 特权指令和非特权指令， 因此CPU执行一条指令前就能判断出其类型 内核态 & 用户态 CPU 有两种状态， “内核态” 和“用户态” 处于内核态时， 说明此时正在运行的是内核程序， 此时可以执行特权指令 处于用户态时， 说明此时正在运行的是应用程序， 此时只能执行非特权指令 拓展： CPU 中有一个寄存器叫 程序状态字寄存器（PSW） ， 其中有个二进制位， 1 表示“ 内核态 ” ， 0 表示“ 用户态 ” 别名： 内核态 = 核心态 = 管态； 用户态 = 目态 内核态、 用户态 的切换 内核态 -> 用户态： 执行一条特权指令——修改PSW的标志位为“ 用户态 ” ， 这个动作意味着操作系统将主动让出CPU使用权 用户态 -> 内核态： 由“ 中断 ” 引发， 硬件自动完成变态过程， 触发中断信号意味着操作系统将强行夺回CPU的使用权 除了非法使用特权指令之外， 还有很多事件会触发中断信号。 一个共性是， 但凡需要操作系统介入的地方， 都会触发中断信号 启动过程： 刚开机时， CPU 为“ 内核态 ” ， 操作系统内核程序先上CPU运行 开机完成后， 用户可以启动某个应用程序 操作系统内核程序在合适的时候主动让出 CPU， 让该应用程序上CPU运行，操作系统内核在让出CPU之前， 会用一条特权指令把 PSW 的标志位设置为“ 用户态 ” 应用程序运行在“ 用户态 ” 此时， 一位猥琐黑客在应用程序中植入了一条特权指令， 企图破坏系统… CPU发现接下来要执行的这条指令是特权指令， 但是自己又处于“ 用户态 ” 这个非法事件会引发一个中断信号，CPU检测到中断信号后， 会立即变为“ 核心态 ” ， 并停止运行当前的应用程序， 转而运行处理中断信号的内核程序 “ 中断 ” 使操作系统再次夺回CPU的控制权 操作系统会对引发中断的事件进行处理， 处理完了再把CPU使用权交给别的应用程序 ```mermaid graph LR; 操作系统的运行机制 -->简单了解程序的运行原理; 简单了解程序的运行原理 --> 高级语言编写代码_机器指令; 简单了解程序的运行原理 --> 程序运行的过程就是CPU执行指令的过程; 操作系统的运行机制 -->俩类程序; 俩类程序 --> 内核程序; 俩类程序 --> 应用程序; 操作系统的运行机制 -->俩类指令; 俩类指令 --> 特权指令; 俩类指令 --> 非特权指令; 操作系统的运行机制 -->俩种处理器状态; 俩种处理器状态 --> 用户态\\目态; 俩种处理器状态 --> 内核态\\管态\\核心态; 操作系统的运行机制 -->内核; 内核 --> 内核kernel是操作系统最重要最核心的部分; 内核 --> 由很多内核程序组成的操作系统内核; 操作系统的运行机制 -->任何换态; 任何换态 --> 内核态-到-用户态 --> 一条修改PSW的特权指令; 任何换态 --> 用户态-到-内核态 --> 由中断触发,硬件自动完成; ``` 两种指令、 两种处理器状态、 两种程序 有的指令“人畜无害” 。 比如： 加、 减、 乘、 除 这些普通的运算指令。 有的指令有很高的权限。 比如： 内存清零指令。 如果用户程序可以使用这个指令， 就意味着一个用户可以将其他用户的内存数据随意清零， 这样做显然是很危险的。 graph LR; 指令 --> 特权指令:如内存清零指令; 指令 --> 非特权指令:如普通的运算指令 特殊指令：不允许用户程序使用 用程序状态字寄存器（PSW） 中的某标志位来标识当前处理器处于什么状态。 如 0 为用户态， 1 为核心态 用户态：此时CPU只能执行非特权指令 核心态：特权指令、 非特权指令都可执行 graph LR; 俩种处理器状态 --> 用户态$目态$ 俩种处理器状态 --> 核心态$管态$ 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令， 也可以执行非特权指令， 运行在核心态。 应用程序：为了保证系统能安全运行， 普通应用程序只能执行非特权指令， 运行在用户态 graph LR; 俩种程序 --> 内核程序 俩种程序 --> 应用程序 操作系统的内核 graph TB; 用户 --- 应用程序$_软件_$ 用户 --- 非内核功能 应用程序$_软件_$ --- 非内核功能 非内核功能 --- 进程管理\\存储器管理\\设备功能等功能 进程管理\\存储器管理\\设备功能等功能 --- 时钟管理 进程管理\\存储器管理\\设备功能等功能 --- 中断处理 进程管理\\存储器管理\\设备功能等功能 --- 原语__$_设备驱动\\CPU切换等_$ 时钟管理 --- 裸机 实现计时功能 --- 时钟管理 中断处理 --- 裸机 原语__$_设备驱动\\CPU切换等_$ --- 裸机 原语是一种特殊的程序,是最靠近硬件的部分,运行具有原子性 --- 原语__$_设备驱动\\CPU切换等_$ 内核是计算机上配置的底层软件， 是操作系统最基本、 最核心的部分。 实现操作系统内核功能的那些程序就是内核程序。 有的操作系统不把这部分功能归为“ 内核功能 ” 。 也就是说， 不同的操作系统， 对内核功能的划分可能并不一样 graph LR; 操作系统内核 --> 时钟管理 --> 实现计时功能; 操作系统内核 --> 中断处理 --> 负责实现中断机制; 操作系统内核 --> 原语; 原语 --> 是一种特殊的程序 原语 --> 处于操作系统最底层,最靠近硬件的部分 原语 --> 运行时间短,调用频繁 原语 --> 这种程序具有原子性__-__只能一气呵成,不能中断 操作系统内核 --> 对系统资源进行管理的功能; 对系统资源进行管理的功能 --> 进程管理 对系统资源进行管理的功能 --> 存储器管理 对系统资源进行管理的功能 --> 设备管理 graph LR; 操作系统的体系结构 --> 大内核 大内核 --> 将操作系统的主要功能模块都作为系统内核,运行在核心态 大内核 --> 优点:高性能 大内核 --> 缺点:内核代码庞大,结构混乱,难以维护 操作系统的体系结构 --> 微内核 微内核 --> 只把最基本的功能保留在内核 微内核 --> 优点:内核功能少,结构清晰,方便维护 微内核 --> 缺点:需要频繁在用户态与核心态切换,性能低 比喻： 内核就是企业的管理层， 负责一些重要的工作。 只有管理层才能执行特权指令， 普通员工只能执行非特权指令。 用户态、 核心态之间的切换相当于普通员工和管理层之间的工作交接 大内核： 企业初创时体量不大， 管理层的人会负责大部分的事情。 优点是效率高； 缺点是组织 结构混乱， 难以维护。 微内核： 随着企业体量越来越大， 管理层只负责最核心的一些工作。 优点是组织结构清晰， 方 便维护； 缺点是效率低。 特权指令只能在核心态下执行 内核程序只能在核心态下执行 graph LR; OS的运行机制和体系机构 --> 运行机制 运行机制 --> 俩种指令 俩种指令 --> 特权指令 俩种指令 --> 非特权指令 运行机制 --> 俩种处理器状态 俩种处理器状态 --> 核心态 俩种处理器状态 --> 用户态 运行机制 --> 俩种程序 俩种程序 --> 内核程序 俩种程序 --> 应用程序 OS的运行机制和体系机构 --> 操作系统内核 操作系统内核 --> 时钟管理 操作系统内核 --> 中断管理 操作系统内核 --> 原语 --> 是一种特殊的程序,具有原子性,不可中断 操作系统内核 --> 对系统资源进行管理的功能 对系统资源进行管理的功能 --> 进程管理 对系统资源进行管理的功能 --> 存储器管理 对系统资源进行管理的功能 --> 设备管理 OS的运行机制和体系机构 --> 操作系统的体系结构 操作系统的体系结构 --> 大内核 大内核 --> 优点:性能高 大内核 --> 缺点:内核庞大,结构复杂,难以维护 操作系统的体系结构 --> 微内核 微内核 --> 优点:功能少,结构清晰,方便维护 微内核 --> 缺点:频繁在用户态与核心态切换,性能低 操作系统的体系结构 graph LR; 操作系统的体系结构 --> 大内核/单内核/宏内核 操作系统的体系结构 --> 微内核 操作系统的内核 操作系统内核需要运行在内核态 操作系统的非内核功能运行在用户态 计算机系统的层次结构 graph TB; 用户 --> 应用程序_$软件$ --> 非内核功能_$GUI$ --> 进程管理/存储器功管理/设备管理 --> 原语_$设备驱动/CPU切换$ --> 裸机 用户 --> 非内核功能_$GUI$ 进程管理/存储器功管理/设备管理 --> 时钟管理 进程管理/存储器功管理/设备管理 --> 中断处理 时钟管理 --> 裸机 中断处理 --> 裸机 内核是操作系统最基本、 最核心的部分。 实现操作系统内核功能的那些程序就是内核程序 graph LR; 操作系统内核 --> 时钟管理 --> 实现计时功能 操作系统内核 --> 中断处理 --> 负责实现中断机制 操作系统内核 --> 原语 --> 一种特殊的程序 原语 --> 处于操作系统最底层,最接近硬件的部分 操作系统内核 --> 对系统资源进行管理的功能 --> 进程管理 对系统资源进行管理的功能 --> 存储器管理 对系统资源进行管理的功能 --> 设备管理 操作系统的体系结构 应用程序想要请求操作系统的服务， 这个服务的处理同时涉及到进程管理、 存储管理、 设备管理 变态的过程是有成本的， 要消耗不少时间， 频繁地变态会降低系统性能 graph LR; 操作系统的体系结构 --> 大内核 --> 将操作系统的主要功能模块都作为系统的内核,运行在核心态 大内核 --> 优点:高性能 大内核 --> 缺点:内核代码庞大,结构混乱,难以维护 操作系统的体系结构 --> 微内核 --> 把最基本的功能保留在内核 微内核 --> 优点:内核功能少,结构清晰,方便维护 微内核 --> 缺点:需要频繁在核心区和用户态之间切换,性能低 系统调用 graph LR; 系统调用 --> 向应用程序提供接口 系统调用 操作系统作为用户和计算机硬件之间的接口， 需要向上提供一些简单易用的服务。 主要包括命令接口和程序接口。 其中， 程序接口由一组系统调用组成 “ 系统调用 ” 是操作系统提供给应用程序（程序员/编程人员） 使用的接口， 可以理解为一种可供应用程序调用的特殊函数， 应用程序可以通过系统调用来请求获得操作系统内核的服务 graph LR; 操作系统向上提供的接口 --> 给用户用 给用户用 --> GUI 给用户用 --> 命令接口 命令接口 --> 脱机命令接口 命令接口 --> 联机命令接口 操作系统向上提供的接口 --> 给应用程序用 给应用程序用 --> 程序接口_$系统调用$ 库和系统调用区别 不涉及系统调用的库函数： 如：“ 取绝对值 ” 的函数 涉及系统调用的库函数： 如 “ 创建一个新文件 ” 的函数 由操作系统内核对共享资源进行统一的管理， 并向上提供“ 系统调用 ” ， 用户进程想要那种共享资源， 只能通过系统调用向操作系统内核发出请求。 内核会对各个请求进行协调处理 普通应用程序 可直接进行系统调用，也可使用库函数，有的库函数涉及系统调用，有的不涉及 编程语言 向上提供库函数，有时将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序编程更方便 操作系统 向上提供系统调用，使的上层程序能请求内核的任务 裸机 graph TB; 应用程序 --> C库函数 --> 系统调用 --> 操作系统 应用程序 --> 系统调用 应用程序通过系统调用请求操作系统的服务。 而系统中的各种共享资源都由操作系统内核统一掌管， 因此凡是与共享资源有关的操作（如存储分配、 I/O操作、 文件管理等） ， 都必须通过系统调用的方式向操作系统内核提出服务请求， 由操作系统内核代为完成。 这样可以保证系统的稳定性和安全性， 防止用户进行非法操作 graph LR; 系统调用_$功能分类$ --> 设备管理 --> 完成设备的请求/释放/启动_等功能 系统调用_$功能分类$ --> 文件管理 --> 完成文件的读写/创建/删除_等功能 系统调用_$功能分类$ --> 进程管理 --> 完成进程的创建/撤销/阻塞/唤醒_等功能 系统调用_$功能分类$ --> 进程通信 --> 完成进程之间的消息传递/信号传递_等功能 系统调用_$功能分类$ --> 内存管理 --> 完成内存的分配/回收_等功能 系统调用的过程 该中断由陷入指令引发， 因此转入相应的中断处理程序——即 系统调用的入口程序 传递系统调用参数 -> 执行陷入指令（用户态） -> 执行相应的内请求核程序处理系统调用（核心态）-> 返回应用程序 陷入指令是在用户态执行的， 执行陷入指令之后立即引发一个内中断， 使CPU进入核心态 发出系统调用请求是在用户态， 而对系统调用的相应处理在核心态下进行 graph LR; 系统调用 --> 操作系统对应用程序提供的接口 系统调用 --> 系统调用与库函数 --> 有的库函数对系统调用的进一步封装 系统调用与库函数 --> 有的库函数没有使用系统调用 系统调用 --> 功能 --> 设备管理 功能 --> 文件管理 功能 --> 进程管理 功能 --> 进程通信 功能 --> 内存管理 系统调用 --> 调用过程 调用过程 --> 传参 调用过程 --> 陷入指令/trap/访管 调用过程 --> 由操作系统内核程序处理系统调用请求 调用过程 --> 返回应用程序 中断和异常 graph LR; 中断和异常 --> 中断的作用 中断和异常 --> 中断的类型 中断的类型 --> 内中断_$异常$ 中断的类型 --> 外中断 中断和异常 --> 中断机制的基本原理 中断的作用 “ 中断 ” 会使CPU由用户态变为内核态， 使操作系统重新夺回对CPU的控制权 CPU 上会运行两种程序， 一种是操作系统内核程序( 整个系统的管理者 )， 一种是应用程序 在合适的情况下， 操作系统内核会把CPU的使用权主动让给应用程序 “ 中断 ” 是让操作系统内核夺回CPU使用权的唯一途径 如 没有“ 中断 ” 机制， 那么一旦应用程序上CPU运行， CPU就会一直运行这个应用程序 内核态 -> 用户态： 执行一条特权指令——修改PSW的标志位为“ 用户态 ” ， 这个动作意味着操作系统将主动让出CPU使用权 用户态 -> 内核态： 由“ 中断 ” 引发， 硬件自动完成变态过程， 触发中断信号意味着操作系统将强行夺回CPU的使用权 我有俩把钥匙，一把是共享单车的( 用户态 )，一把是法拉利的 ( 内核态 )，我要速度激情，闪电飘逸就肯定要开法拉利，不可能用共享单车遨游天空把，我开着法拉利可以到富人区，也能到贫民区，开着共享单车就只能在贫民区，要是去富人区，会被打断狗腿，所以，要开法拉利去装*呀 中断的类型 graph LR; 中断的类型 --> 内中断 中断的类型 --> 外中断 内中断：与当前执行的指令有关，中断信号来源于CPU内部 外中断：与当前执行的指令无关，中断信号来源于CPU外部 内中断可以看出家里的媳妇要你去干事，你不能抗拒呀，外中断，就是外面的彩旗要你去做事，你也要去处理 内中断 与当前执行的指令有关，中断信号来源于CPU内部 若当前执行的指令是非法的， 则会引发一个中断信号 如： ​ 试图在用户态下执行特权指令 ​ 执行除法指令时发现除数为 0 有时候应用程序想请求操作系统内核的服务， 此时会执行一条特殊的指令——陷入指令， 该指令会引发一个内部中断信号 执行“ 陷入指令 ” ， 意味着应用程序主动地将CPU控制权还给操作系统内核。 “ 系统调用 ” ：通过陷入指令完成的 外中断 当前执行的指令无关，中断信号来源于CPU外部 每一条指令执行结束时， CPU都会例行检查是否有外中断信号 时钟中断——由时钟部件发来的中断信号 I/O中断——由输入/输出设备发来的中断信号 中断的分类 graph LR; 中断的分类 --> 内中断_$_异常\\例外_$ 内中断_$_异常\\例外_$ --> 陷入\\陷阱_trap 内中断_$_异常\\例外_$ --> 故障_fault 内中断_$_异常\\例外_$ --> 终止_abort 中断的分类 --> 外中断_中断_$ 外中断_中断_$ --> 时钟中断 外中断_中断_$ --> I\\O中断请求 中断机制的基本原理 不同的中断信号， 需要用不同的中断处理程序来处理。 当CPU检测到中断信号后， 会根据中断信号的类型去查询“ 中断向量表 ” ， 以此来找到相应的中断处理程序在内存中的存放位置 中断处理程序一定是内核程序， 需要运行在“ 内核态 ” 外面彩旗太多，当有彩旗找你，你肯定要用微信查一下是几号鱼，要不然找到她，都不知道叫什么，然后你要开着法拉利去，不能用共享单车去撩吧。 graph LR; 中断和异常 --> 中断的作用 中断的作用 --> 让操作系统的内核剥夺CPU的控制权 中断的作用 --> 让CPU从用户态转换为内核态 中断和异常 --> 中断的分类 中断的分类 --> 内中断_异常\\例外 内中断_异常\\例外 --> 陷入\\陷阱_trap 内中断_异常\\例外 --> 故障_fault 内中断_异常\\例外 --> 终止_abort 中断的分类 --> 外中断_中断 外中断_中断--> 时钟中断 外中断_中断--> I/O中断请求 中断和异常 --> 中断机制的基本实现原理 中断机制的基本实现原理 --> 检查中断信号 检查中断信号 --> 内中断:CPU在执行指令时会检查是否有异常发生 检查中断信号 --> 外中断:每个指令周期末尾,CPU都会检查是否有外中断信号需要处理 中断机制的基本实现原理 --> 找到相应的中断处理程序 找到相应的中断处理程序 --> 通过_中断向量表_实现 graph LR; OS概叙 --> OS的概念和功能 --> 向上提供接口 OS的概念和功能 --> 对下层功能的拓展 OS的概念和功能 --> 对系统资源的管理 OS概叙 --> OS的发展/特征 OS概叙 --> OS的运行机制 OS的运行机制 --> 俩种程序/俩种CPU状态/俩种指令 OS概叙 --> OS体系结构 OS体系结构 --> 大内核/微内核 OS概叙 --> 系统调用 系统调用 --> 作用 系统调用 --> 系统调用过程 系统调用 --> 陷入/trap/访管指令 OS概叙 --> 中断和异常 中断和异常 --> 何作用 中断和异常 --> 区别 中断和异常 --> 处理 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:10:12 "},"operating_system/process.html":{"url":"operating_system/process.html","title":"进程","keywords":"","body":" 进程的 概念、 组成、特征 @Author: cpu_code @Date: 2020-07-11 17:26:29 @LastEditTime: 2020-07-12 21:09:52 @FilePath: \\note\\operating_system\\process.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ graph LR; 进程 --> 概念 --> 理解进程与程序的区别 进程 --> 组成 --> 一个进程由那些部分构成 进程 --> 特征 --> 进程有那些重要的特点 进程的概念 程序： 是静态的， 就是个存放在磁盘里的可执行文件， 就是一系列的指令集合。 进程（Process） ： 是动态的， 是程序的一次执行过程 同一个程序多次执行会对应多个进程 PCB 当进程被创建时， 操作系统会为该进程分配一个唯一的、 不重复的“ 身份证号 ” —— PID（Process ID， 进程ID） 操作系统要记录 PID、 进程所属 用户ID（UID），基本的进程描述信息， 可以让操作系统区分各个进程 还要记录给进程分配了哪些资源（如： 分配了多少内存、 正在使用哪些I/O设备、 正在使用哪些文件），可用于实现操作系统对资源的管理 还要记录进程的运行情况（如： CPU使用时间、 磁盘使用情况、 网络流量使用情况等），可用于实现操作系统对 进程的控制、 调度 这些信息都被保存在一个数据结构PCB （ Process Control Block ） 中， 即进程控制块 操作系统需要对各个并发运行的进程进行管理， 但凡管理时所需要的信息， 都会被放在PCB中 PCB是进程存在的唯一标志， 当进程被创建时， 操作系统为其创建PCB， 当进程结束时， 会回收其PCB 操作系统对进程进行管理工作所需的信息都存在PCB中 graph LR; 进程控制块_PCB___ --> 进程描述信息 --> 进程标识符PID 进程描述信息 --> 用户标识符UID 进程控制块_PCB___ --> 进程控制和管理信息 --> CPU\\磁盘\\流量使用情况统计 进程控制和管理信息 --> 进程当前状态:就绪态/阻塞态/运行态 进程控制块_PCB___ --> 资源分配清单 资源分配清单 --> 正在使用那些文件 资源分配清单 --> 正在使用那些内存区域 资源分配清单 --> 正在使用那些IO设备 进程控制块_PCB___ --> 处理机相关信息 --> 如PSW/PC等各种寄存器的值_用于实现进程切换_ 程序段、 数据段 PCB 是给操作系统用的 程序段、 数据段是给进程自己用的 graph LR; 进程的组成 --> PCB --> 进程描述信息 PCB --> 进程控制和管理信息 PCB --> 资源分配清单 PCB --> 处理机相关信息 进程的组成 --> 程序段 --> 程序代码_指令序列_ 进程的组成 --> 数据段 --> 运行过程中产生的各种数据_如:程序中定义的变量_ 一个进程实体（进程映像） 由PCB、 程序段、 数据段组成 进程是动态的， 进程实体（进程映像） 是静态的 进程实体反应了进程在某一时刻的状态（如： x++后， x=2） 程序段、 数据段、 PCB三部分组成了进程实体（进程映像） 引入进程实体的概念后， 可把进程定义为： ​ 进程是进程实体的运行过程， 是系统进行资源分配和调度的一个独立单位。 一个进程被“ 调度 ” ， 就是指操作系统决定让这个进程上CPU运行 注意： PCB是进程存在的唯一标志！ 进程的特征 动态性是进程最基本的特征 异步性会导致并发程序执行结果的不确定性。 程序是静态的， 进程是动态的， 相比于程序， 进程拥有以下特征： graph LR; 进程的特征 --> 动态性 --> 进程是程序一次执行过程,是动态生成/变化/灭亡 进程的特征 --> 并发性 --> 内存中有多个进程实体,各进程可并发执行 进程的特征 --> 独立性 --> 进程是独立运行/独立获取资源/独立接受调度的基本单位 进程的特征 --> 异步性 --> 各进程按各自独立的/不可预知的速度向前推进 进程的特征 --> 结构性 --> 执行过 进程组织 在一个系统中， 通常有数十、 数百乃至数千个PCB。 为了能对他们加以有效的管理， 应该用适当的方式 把这些PCB组织起来 链接方式 执行指针 指向当前处于运行态（执行态） 的进程 单CPU计算机中， 同一时刻只会有一个进程处于运行态 就绪队列指针 指向当前处于就绪态的进程 杜塞队列指针 指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同， 再分为多个阻塞队列 通常会把优先级高的进程放在队头 graph LR; 执行指针 --> PCB1 就绪队列指针 --> PCB2 --> PCB4 杜塞队列指针 --> PCB5 --> PCB3 索引方式： graph LR; 执行指针 --> PCB1 就绪队列指针 --> 就绪索引表 --> PCB2 就绪索引表 --> PCB4 杜塞队列指针 --> 堵塞索引表 --> PCB5 堵塞索引表 --> PCB3 graph LR; 进程的组织方式 --> 链接方式 链接方式 --> 按照进程状态将PCB分为多个队列 链接方式 --> 操作系统持有指向各个队列的指针 进程的组织方式 --> 索引方式 索引方式 --> 根据进程状态的不同,建立几张索引表 索引方式 --> 操作系统持有指向各个索引表的指针 进程的状态与转换 三种基本状态：运行态、就绪态、堵塞态 graph LR; 进程的状态与转换 --> 状态 --> 运行态 状态 --> 就绪态 状态 --> 堵塞态 状态 --> 创建态 状态 --> 终止态 进程的状态与转换 --> 状态间的转换 --> 就绪态to运行态 状态间的转换 --> 运行态to就绪态 状态间的转换 --> 运行态to堵塞态 状态间的转换 --> 阻塞态to就绪态 进程的状态与转换 --> 进程的组织方式_各个进程PCB的组织方式 进程的状态——创建态、 就绪态 进程正在被创建时， 它的状态是“创建态” ， 在这个阶段操作系统会为进程分配资源、 初始化PCB 当进程创建完成后， 便进入“就绪态” ，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU， 就暂时不能运行 进程的状态——运行态 系统中可能会有很多个进程都处于就绪态 当CPU空闲时， 操作系统就会选择一个就绪进程，让它上处理机运行 在获得所需资源之前， 进程无法再往下执行 如果一个进程此时在CPU上运行， 那么这个进程处于“ 运行态 ” 。CPU会执行该进程对应的程序（执行指令序列） 进程的状态——阻塞态 当等待的事件发生时， 进程从“阻塞态” 回到 “就绪态” 在进程运行的过程中， 可能会请求等待某个事件的发生（如等待某种系统资源的分配， 或者等待其他进程的响应） 。在这个事件发生之前， 进程无法继续往下执行， 此时操作系统会让这个进程下CPU， 并让它进入“阻塞态”当CPU空闲时， 又会选择另一个“就绪态” 进程上CPU运行 进程的状态——终止态 一个进程可以执行 exit 系统调用， 请求操作系统终止该进程。此时该进程会进入“ 终止态 ” ， 操作系统会让该进程下CPU，并回收内存空间等资源， 最后还要回收该进程的PCB。当终止进程的工作完成之后， 这个进程就彻底消失了 进程状态的转换 注意： 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的， 必然需要进程在运行时才能发出这种请求） 进程的状态 进程的整个生命周期中，大部分时间都处于三种基本状态 单CPU情况下，同一时刻只会有个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态 graph LR; 三种基本状态 --> 运行态_Running 运行态_Running --> 占有CPU,并在CPU上运行 三种基本状态 --> 就绪态_Ready 就绪态_Ready --> 已经具备运行条件,但由于没有空闲CPU,而暂时不能运行 三种基本状态 --> 阻塞态_Waiting/Blocked_反称:等待态 阻塞态_Waiting/Blocked_反称:等待态 --> 因等待某一事件而暂时不能运行 graph LR; 另外两种状态 --> 创建态_new_又称新建态 创建态_new_又称新建态 --> 进程正在被创建,操作系统为进程分配资源\\初始化PCB 另外两种状态 --> 终止态_Terminated_又称结束态 终止态_Terminated_又称结束态 --> 进程正在从系统中撒销,操作系统会回收进程拥有的资源\\撤销PCB 进程PCB中，会有一个变量 state 来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来 进程的组织 graph LR; 进程的组织方式 --> 链接方式 链接方式 --> 按照进程状态将PCB分为多个队列 链接方式 --> 操作系统持有指向各个队列的指针 进程的组织方式 --> 索引方式 索引方式 --> 根据进程状态的不同,建立几张索引表 索引方式 --> 操作系统持有指向各个索引表的指针 进程的状态——三种基本状态 进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态 进程的三种基本状态： graph LR; 三种基本状态 --> 运行态_Running 运行态_Running --> 占有CPU,并在CPU上运行 三种基本状态 --> 就绪态_Rsy 就绪态_Rsy --> 已经具备运行条件,但由于没有空闲CPU,而暂时不能运行 三种基本状态 --> 阻塞态_Waiting/Blocked_又称:等待态 阻塞态_Waiting/Blocked_又称:等待态 --> 因等待某一事件而暂时不能运行 注意：单核处理机环境下，每一时刻最多只有一个进程处于运行 进程已经拥有了除处理机之外所时刻有需要的资源，一旦获得处理机，即可立即进入运行态开始运行，即: 万事俱备, 只欠CPU 如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是最昂贵的部件, 为了提高CPU的利用率, 需要先将其他进程需要的资源分配到位, 才能得到CPU的服务 进程的状态——另外两种状态 进程运行结束（或者由于bug导致进程无法继续执行下去， 比如数组越界错误） ， 需要撤销进程。 操作系统需要完成创建进程。 操作系统为该进程分配所需的内存空间等系统资源， 并为其创建、初始化PCB（如： 为进程分配 PID） graph LR 另外俩种状态 --> 创建态_New_新建态_ 创建态_New_新建态_ --> 进程正在被创建,操作系统为进程分配资源,初始化PCB 另外俩种状态 --> 终止态_Terminated_结束态_ 终止态_Terminated_结束态_ --> 进程正在从系统中撤销,操作系统会回收进程拥有的资源,撤销PCB graph LR 进程的状态 --> 运行态 进程的状态 --> 就绪态 进程的状态 --> 阻塞态 进程的状态 --> 创建态 进程的状态 --> 终止态 进程控制 进程控制的主要功能是对系统中的所有进程实施有效的管理， 它具有创建新进程、 撤销已有进程、 实现进程状态转换等功能。 进程控制就是要实现进程状态转换 graph LR 创建态 --> 就绪态 就绪态 --> 运行态 运行态 --> 就绪态 运行态 --> 终止态 运行态 --> 阻塞态 阻塞态 --> 就绪态 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:10:01 "},"linux_in_a_word/network_indepen.html":{"url":"linux_in_a_word/network_indepen.html","title":"与网络无关的Linux","keywords":"","body":" 网络无关 @Author: cpu_code @Date: 2020-07-12 14:09:20 @LastEditTime: 2020-07-12 21:08:35 @FilePath: \\note\\android_bottom\\smart_pointer.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ 修改主机名 vi /etc/sysconfig/network # 修改 HOSTNAME 一行为 (没有这行, 那就添加这一行吧) HOSTNAME=主机名 # 运行命令 hostname # 主机名 一般还要修改 /etc/hosts 文件中的主机名。这样，无论你是否重启，主机名都修改成功 Ret Hat Linux 启动到文字界面(不启动 xwindow) # x=3:文本方式 x=5:图形方式 vi /etc/inittab id:x:initdefault: linux 的自动升级更新问题 对于 redhat，在 www.redhat.com/corp/support/errata/ 找到补丁， 6.1 以后的版本带有一个工具up2date，它能够测定哪些 rpm 包需要升级，然后自动从 redhat 的站点下载并完成安装 # 升级除 kernel 外的 rpm up2date -u # 升级包括 kernel 在内的 rpm up2date -u -f 由于 Red Hat Network SSL 证书过期，所以应在 rhn_register || up2date 之前先执行一行 script 以更新证书： wget -q -O - https://rhn.redhat.com/help/new-cert.sh | /bin/bash Debian 下升级软件： # 前提：配置好网络和 /etc/apt/sources.list，也可以用 apt-setup 设置 apt-get update apt-get upgrade windows 下看 linux 分区的软件 Paragon.Ext2FS.Anywhere.2.5.rar explore2fs-1.00-pre4.zip mount 用法 # fat32 的分区 mount -o codepage=936,iocharset=cp936 /dev/hda7 /mnt/cdrom # ntfs 的分区 mount -o iocharset=cp936 /dev/hda7 /mnt/cdrom # iso 文件 mount -o loop /abc.iso /mnt/cdrom # USB 闪存 mount /dev/sda1 /mnt/cdrom # 软盘 mount /dev/fd0 /mnt/floppy 在 vmware 的 LINUX 中使用本地硬盘的 FAT 分区 删除名为-a 的文件 rm ./-a 删除名为\\a 的文件 rm \\\\a 删除名字带的/和‘\\0'文件 删除名字带不可见字符的文件 删除文件大小为零的文件 redhat 设置滚轮鼠标 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:09:47 "},"linux_kernel_0_12/computer_composition.html":{"url":"linux_kernel_0_12/computer_composition.html","title":"微型计算机组成结构","keywords":"","body":" 微型计算机组成结构 @Author: cpu_code @Date: 2020-07-11 20:36:18 @LastEditTime: 2020-07-12 21:09:37 @FilePath: \\note\\linux_kernel_0_12\\computer_composition.md @Gitee: https://gitee.com/cpu_code @Github: https://github.com/CPU-Code @CSDN: https://blog.csdn.net/qq_44226094 @Gitbook: https://923992029.gitbook.io/cpucode/ 任何一个系统都可认为由四个基本部分组成 输入部分用于接收进入系统的信息或数据 , 经过处理中心加工后 , 再由输出部分送出 能源部分为整个系统提供操作运行的能源供给，包括输入和输出部分操作所需要的能量 计算机系统的处理中心与输入/输出部分之间的通道或接口都是共享使用的 计算机系统可分为硬件部分和软件部分，但两者之间互相依存 微型计算机组成原理 CPU 通过地址线、数据线和控制信号线组成的本地总线（或称为内部总线）与系统其他部分进行数据通信 地址线用于提供内存或 I/O 设备的地址，即指明需要读/写数据的具体位置。 数据线用于在 CPU 和内存或 I/O 设备之间提供数据传输的通道 . 控制线负责指挥执行的具体读/写操作。 传统 IBM PC 及其兼容计算机的组成框图 : Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-07-12 21:10:43 "}}