





# 数组和字符串

## 数组简介

### 集合、列表和数组

#### 集合

集合一般被定义为：由一个或多个确定的元素所构成的整体。

**集合里的元素类型不一定相同**

**集合里的元素没有顺序**



#### 列表

列表（又称线性列表）的定义为：是一种数据项构成的**有限序列**，即按照一定的**线性顺序**，排列而成的数据项的集合。

列表的概念是在集合的特征上形成的，它具有**顺序**，且**长度是可变**的。

编程语言中，列表最常见的表现形式有**数组**和**链表**，**栈**和**队列**则是两种特殊类型的列表。



#### 数组

数组是列表的实现方式之一

数组是**列表**的实现方式，它具有列表的特征，同时也具有自己的一些特征。

在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。

比如 C++ 和 Java 中，数组中的元素类型必须保持一致

而 Python 中则可以不同。Python 中的数组叫做 list 

从宏观上区分列表和数组 , 重要的概念：**索引**

首先，数组会用一些名为 `索引` 的数字来**标识**每项数据在**数组的位置**，且在大多数编程语言中，**索引**是从 `0` 算起的。我们可以根据数组中的索引，快速访问数组中的元素。

<img src="https://gitee.com/cpu_code/picture_bed/raw/master//20200629211909.png" alt="4.png" style="zoom: 67%;" />

**列表中没有索引**，这是数组与列表**最大的不同点**

数组中的元素在内存中是**连续存储**的，且每个元素占用相同大小的内存。

数组在内存中的存储方式 : 

<img src="https://gitee.com/cpu_code/picture_bed/raw/master//20200629211958.png" alt="5.png" style="zoom:50%;" />

列表中的元素在内存中可能**彼此相邻**，也可能**不相邻**。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。



### 数组的操作

#### 读取元素

读取数组中的元素，即通过数组的索引访问数组中的元素。

**索引**其实就是**内存地址**，计算机可以跳跃到任意的内存地址上，也就是只要计算出数组中元素的内存地址，就可以一步访问到数组中的元素

将计算机中的内存看作一系**列排列好的格子**，这些格子中，每一个格子对应一个**内存地址**，数据会存储在不同的格子中。

<img src="https://gitee.com/cpu_code/picture_bed/raw/master//20200629212808.png" alt="1.png" style="zoom: 33%;" />

对于数组，计算机会在内存中申请一段 **连续** 的空间，并且会记下索引为 `0` 处的内存地址。



例如对于一个数组 `['oranges', 'apples', 'bananas', 'pears', 'tomatoes']`

假设每个元素只占用一个字节，它的 索引 与 内存地址的关系 : 

<img src="https://gitee.com/cpu_code/picture_bed/raw/master//20200629212828.png" alt="2.png" style="zoom:50%;" />

当我们访问数组中索引为 `3` 处的元素时，计算机会进行如下计算：

-   找到该数组的索引 `0` 的内存地址： `2008`；
-   `pears` 的索引为 `3`，计算该元素的内存地址为 `2008 + 3 = 2011`；

接下来，计算机就可以在直接通过该**地址访问**到数组中索引为 `3` 的元素了，时间复杂度为 O(1)。



#### 查找元素

计算机只会保存数组中索引为 `0` 处元素的内存地址，因此当计算机想要知道数组中是否包含某个元素时，只能从索引 `0` 处开始，逐步向后查询。

如 我们要查找数组中是否包含元素 `pears`，计算机会从索引 `0` 开始，逐个比较对应的元素，直到找到该元素后停止搜索，或到达数组的末尾后停止。

该数组的长度为 `5`，最坏情况下（如 :  我们查找元素 `tomatoes` 或 查找数组中不包含的元素），我们需要查询数组中的每个元素，因此时间复杂度为 O(N) ，N 为数组的长度。

<img src="https://pic.leetcode-cn.com/e592cf43d44a9e8f7a15b85c9fd6679668fc36134b10161bfc430b85491c8b9e-3.gif" alt="3.gif" style="zoom:50%;" />



#### 插入元素

假如在原有的数组中再插入一个元素 `flowers` 

如果要将该元素插入到数组的末尾，只需要一步。

即计算机通过数组的**长度**和**位置**计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。



<img src="https://pic.leetcode-cn.com/c3074c34fd36fd6f8b042421660705e2b376046fe50bc4af9fddc176e19f3eab-4.gif" alt="4.gif" style="zoom: 50%;" />

如果要将该元素插入到数组中的其他位置，则会有所区别

这时我们首先需要为该元素所要插入的位置`腾出` 空间，然后进行插入操作

比如，我们想要在索引 `2` 处插入 `flowers` :

<img src="https://pic.leetcode-cn.com/27ee29524a3538e4c1de14953698a66b3e860e6b4984c1f454eb91fa9fbbc2f3-5.gif" alt="5.gif" style="zoom:50%;" />

如果需要频繁地对**数组元素**进行插入操作，会造成时间的浪费。数据结构的**链表**就有效解决这个问题



#### 删除元素

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 `空缺` 的位置，而数组中的元素在内存中是**连续的**，这就使得后面的元素需对该位置进行 `填补` 操作。

以删除索引 `1` 中的元素 `apples`  :

<img src="https://pic.leetcode-cn.com/20e80a7fd6d2d34ec8d59dffe1da115c76dd1c06a9a2959a03d3261a1eab67a4-6.gif" alt="6.gif" style="zoom:50%;" />

数组的长度为 `5`，最坏情况下，我们删除第一个元素，后面的 `4` 个元素需要向前移动，加上删除操作，共需执行 `5` 步，因此时间复杂度为 *O*(*N*)，N 为数组的长度。



### 寻找数组的中心索引

给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。

我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

**示例 1：**

```python
输入：
nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
同时, 3 也是第一个符合要求的中心索引。
```

**示例 2：**

```python
输入：
nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心索引。
```

**说明：**

-   `nums` 的长度范围为 `[0, 10000]`。
-   任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。

```c
int pivotIndex(int* nums, int numsSize)
{
    int i = 0;
    int Lsum = 0;
    int Rsum = 0;
    
    //判断数组是否为空
    if(numsSize == 0)
    {
        return -1;
    }
    
    //先把右边和
    for(i = 1; i < numsSize; i++)
    {
        Rsum += nums[i];
    }
    
    //判断右边是不是为零
    if(Lsum == Rsum)
    {
        return 0;
    }
    
    for(i = 1; i < numsSize; i++)
    {
        Lsum += nums[i - 1];
        Rsum -= nums[i];
        
        //判断是否为一样
        if(Lsum == Rsum)
        {
            return i;
        }
    }
    
    return -1;
}
```



### 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

```c
//这是真操作, 但代码不会通过
int searchInsert(int* nums, int numsSize, int target)
{
    int i = 0;
    
    if(numsSize == 0)
    {
        nums[0] = target;
        
        return 0;
    }
    
    for(i = numsSize - 1; i >= 0; i--)
    {
        if(target > nums[i])
        {
            nums[i + 1] = target;
            
            return i + 1;
        }
        nums[i + 1] = nums[i];
    }
    
    nums[i + 1] = target;

    return i + 1;
}
```

```c
//通过代码
int searchInsert(int* nums, int numsSize, int target)
{
    int i = 0;
    
    if(target > nums[numsSize-1])
    {
        return numsSize;
    }
    
    for(i = 0; i < numsSize; i++)
    {
        if(nums[i] >= target)
        {
            return i;
        }
    }
    
    return -1;
}
```



###  合并区间

给出一个区间的集合，请合并所有重叠的区间。

**示例 1:**

```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```c

```



## 二维数组简介

二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。

<img src="https://gitee.com/cpu_code/picture_bed/raw/master//20200630103429.png" alt="1.png" style="zoom:50%;" />

二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 `0` 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

### 示例

类似一维数组，对于一个二维数组 `A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]`，计算机同样会在内存中申请一段 **连续** 的空间，并记录第一行数组的索引位置，即 `A[0][0]` 的内存地址，它的索引与内存地址的关系

<img src="https://gitee.com/cpu_code/picture_bed/raw/master//20200630103445.png" alt="2.png" style="zoom:50%;" />

实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 `1`。

实际题目中，往往使用二维数据处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。

### 旋转矩阵

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```













## 字符串简介







## 双指针技巧







## 小结







