威泰视信嵌入式软件工程师笔试题答题时间 **45分钟**

选择题

1、以下不需要编译内核的情况是

A、删除系统不用的设备驱动程序时

B、升级内核时

C、添加新硬件时

D、激活网卡

>   只要你代码或配置有改动，都要重新编译的，只是如果代码写成块模式的，不用整个代码都重新编译，编译器会自动编译改动了的代码。ABC都改动了原有的配置，D没有，选择D。
>
>   激活网卡就用 `ifconfig eth0 up`



2、内核不包括的子系统是(  )

A、进程管理系统

B、内存管理系统

C、/O管理系统

D、硬件管理系统

>   内核分为进程管理子系统，内存管理子系统，IO管理子系统，文件管理子系统 
>
>   D



3, unsigned short hash(uinsigned short key)  Return( key >> 4)%256; 请问hash(16) ,  hash(256) 的值分别是 (  )

A、1,16

B  8 , 32

C、4,16

D、1,32

>    key = 256 = 0000 0001 0000 0000,  >> 4  = 0001 0000  key = 16 = 0000 0000 0001 0000 = 0001



4、烧写到 FLASH 里的是 (  ) 格式的文件

A、.asm

B .bin

C、.obj

D  .cpp

>   B .bin



5、汇编程序中的伪指令是在( ) 阶段起作用

A、编辑

B、链接

C、编译

D、执行

>   C、编译



6、经过汇编后,生成的目标文件的后经名为( )

A、.C

B .s

C .o

D  .exe

>   -   预处理,生成 .i 的文件[预处理器cpp]
>
>   -   2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]
>
>   -   3、有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]
>
>   -   4、连接目标代码, 生成可执行程序 [链接器ld]
>
>       
>
>       .c为后缀的文件，C语言源代码文件
>
>       .a为后缀的文件，是由目标文件构成的档案库文件；
>
>       .C，.cc或.cxx 为后缀的文件，是C++源代码文件；
>
>       .h为后缀的文件，是程序所包含的头文件；
>
>       .i 为后缀的文件，是已经预处理过的C源代码文件；
>
>       .ii为后缀的文件，是已经预处理过的C++源代码文件；
>
>       .m为后缀的文件，是Objective-C源代码文件；
>
>       .o为后缀的文件，是编译后的目标文件；
>
>       .s为后缀的文件，是汇编语言源代码文件；
>
>       .S为后缀的文件，是经过预编译的汇编语言源代码文件。



7、对代码文件 code.c 编译,  生成可调式代码的命令是()

A、#gcc - g code.c  - o code 

B、# gcc  code.C  - o code

C、#c - g  code. c  code

D、#gcc - g code

>   g++命令中 -g 表示生成的文件是可调试的，如果没有-g，调试时无法命中断点。
>
>   A、#gcc - g code.c  - o code 




8、 nand flash 和 nor flash的区别正确的是() 

A、nor 的读速度比nand稍慢

B、nand的擦除速度远比nor慢

C、nand的写入速度比nor 慢很多

D、nand的擦除单元更小,  擦出电路更少

>   NOR的读速度比NAND稍快一些。
>
>   NAND的写入速度比NOR快很多。
>
>   NAND的4ms擦除速度远比NOR的5s快。
>
>   大多数写入操作需要先进行擦除操作。
>
>   NAND的擦除单元更小，相应的擦除电路更少。
>
>    NOR Flash 来运行启动代码
>
>   Nand-flash存储器具有容量较大，改写速度快等优点，适用于大量数据的存储
>
>   D. nand的擦除单元更小,  擦出电路更少



简答题

1、写出 Linux下的cmd命令,  显示文件、拷贝、删除。

>   ls 
>
>   cp
>
>   mv
>
>   ![image-20200622101738727](https://gitee.com/cpu_code/picture_bed/raw/master//20200622101745.png)



2、关键字 volatile 有什么意义?

>   中断服务程序中修改的供其它程序检测的变量需要加volatile； 
>
>   多任务环境下各任务间共享的标志应该加volatile； 
>
>   存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义； 
>
>   变量是随时可能发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错



3、ICMP是什么协议?  处于网络分层的那一层?

>   ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。属于网络层协议
>
>   控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。



4、程序的全局变量、局部变量和动态申请数据分别位于哪些存储区中?

>   根据 作用域 可分为 **全局**变量 和 **局部**变量。
>
>   根据 生存周期 可分为 **静态存储**方式 和 **动态存储**方式，具体地又分为自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）
>
>   **静态**存储方式 是指 在程序运行期间分配固定的存储空间的方式，**动态**存储方式是 在程序运行期间根据需要进行动态的分配存储空间的方式。
>
>   局部变量存在于（ **堆栈** ）中，全局变量存在于（ **静态区** ）中，动态申请数据存在于（ **堆** ）中



5、使用gcc编译生成可执行文件要经历的那些步骤?

>   一、预处理（生成预编译文件 ，.i文件）
>
>   ```shell
>   gcc –E hello.c –o hello.i //一定.c作为后缀，让gcc识别
>   ```
>
>   预处理过程主要处理那些源代码中以 `#` 开始的预编译指令，主要处理规则如下：
>
>   ① 将所有的 `#define` 删除，并且展开所有的宏定义；
>
>   ②处理所有条件编译指令，如 `#if` ，`#ifdef` 等；
>
>   ③处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。该过程递归进行，及被包含的文件可能还包含其他文件。
>
>   ④删除所有的注释 `//` 和 `/* */` ；
>
>   ⑤添加行号和文件标识，如 #2 “ hello.c ” 2, 以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息；
>
>   ⑥保留所有的 `#pragma` 编译器指令，因为编译器须要使用它们；
>
>   
>
>   二、编译（生成预编译文件 ，.s文件）
>
>   ```shell
>   gcc –S hello.i –o hello.s //可以不用指定名字，默认生成一个.s文件
>   ```
>
>   编译过程 就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件。
>
>   
>
>   三、汇编(生成汇编代码，.o文件)
>
>   ```shell
>   gcc –c hello.s –o hello.o //可以不指定，默认生成.o的文件
>   ```
>
>   汇编器 是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。
>
>   
>
>   四、链接（生成可执行文件）
>
>   ```shell
>   gcc hello.o –o hello
>   ```
>
>   链接器 ld 将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。
>
>   
>
>   假定我们有一个程序名为 hello.c 的C语言源代码文件，要生成一个可执行文件，最简单的办法就是∶
>
>   ```shell
>   gcc hello.c -o myhello 	//一步即可完成
>   ```
>
>   这时，预编译、编译连接一次完成，生成一个系统预设的名为 myhello.out 的可执行文件。



6 用一句话概括 Makefile的作用。

>   makefile文件和make工具一起使用，用于控制工程项目的编译和链接，也可以用来编写手册页和程序的安装。make工具用于解释执行makefile文件中的内容。makefile文件中通常包含源文件和目标文件的依赖关系以及从源文件生成目标文件的规则。make工具可以根据makefile判断哪些文件需要被重新编译，目标文件的构建顺序等。



7、简述看门狗的作用。

>   软件看门狗：一些重要的程序，必须让它一直跑着；而且还要时时关心它的状态——不能让它出现死锁现象。当然，如果一个主程序会出现死锁，肯定是设计或者编程上的失误。我们首要做的事是，把这个Bug揪出来。但如果时间紧迫，这个Bug又“飘忽不定”，那么，我们还是先写一个软件“看门狗”，暂时应一下急吧。
>
>    硬件看门狗：在初始化的时候配置一下寄存器，那么这个时候就可以给硬件看门狗发送喂狗指令了。硬件看门狗,又叫 watchdog timer,是一个定时器电路, 一般有一个输入,叫喂狗,一个输出到MCU的RST端,MCU正常工作的时候,每隔一端时间输出一个信号到喂狗端,给 WDT 清零,如果超过规定的时间不喂狗,(一般在程序跑飞时),WDT 定时超过,就回给出一个[复位信号]到MCU,是MCU复位. 防止MCU死机. 看门狗的作用就是防止程序发生死循环，或者说程序跑飞。



8、什么是 Cache?

>   `cache` 就是 高速数据交换的存储器 , 简称 缓存，它先于内存与CPU交换数据，因此速率很快 , 主要是解决CPU和内存之间的数据传输速度差异  . 一般分为 L1 cache ,  L2 cache ,  L3 cache , 看成金字塔形结构 , 是上层的存储设备容量越小、速度越快、价格也越贵，而越是下层的存储设备容量越大、速度越慢、价格也越便宜



9、用预处理指令 #define 声明一个常量,  用以表明一个有10位地址线的 FLASH的最大存储容量,  单位 bit。



```c
//1 字节(B, byte) = 8位(b, bit)
//2^10 = 1024bit = 128 B
#define MAXADDR 1024
```





10 int id[ sizeof(unsigned long) ],   这个表达式是否正确? 表达的是什么?

>   正确 , 先运算 sizeof，得出 unsigned long 的字节长度 , 这个值是根据每个机器决定 , 一般为 4字节 或 8字节 , 所以可以看成常量



问答题

1、如果有一个简单的 helloworld项目目录如下:

\# tree helloworld

Helloworld

I- file2. h

I- filel. cpp

I- file2. cpp 

请编写一个 Makefile文件。

>   ```makefile
>   Helloworld : filel.o file2.o
>   	g++ -o Helloword filel.o file2.o
>   
>   filel.o : filel.cpp 
>   	g++ -c filel.cpp
>   
>   file2.o : file2.cpp file2.h
>   	g++ -c file2.cpp
>   
>   .PHONY : clean
>   clean :
>   	rm Helloworld *.o
>   ```



2、简述嵌入式linux系统开发流程

>   开发目标硬件系统 : 选择处理器、Flash等
>
>    建立交叉开发环境 : 安装交叉编译工具链（如 arm-linux-gcc ）、设置好环境变量、配置串口通信工具（如超级终端、*SecureCRT*等）、配置网络通信工具（如*NFS*）等 
>
>   建立引导装在程序的bootloader : u-boot , 完成初始化，引导内核，下载、烧写等
>
>   移植嵌入式Linux操作系统 : Linux 内核的移植
>
>   建立根文件系统 :  如 busybox ,  修改根文件系统中的启动脚本，它的存放位置至于/etc目录下
>
>    开发相关的硬件驱动程序  :  如*LCD*、网卡、*GPIO*等
>
>   开发应用程序 : 如 网络  , QT ,  android
>
>   烧写内核、根文件系统、应用程序
>
>   发布产品



3、什么是 Bootloader?  bootloader 有哪两种工作模式,  分别应用在什么情况下?

>   **BootLoader** 是在操作系统内核运行之前运行的一个小程序。可以通过这个小程序，初始化硬件设备、然后建立内存空间的映射，这样就方便最终调用操作系统内核做了一个合适的环境
>
>    BootLoader 的工作模式 （Operation Mode）:
>
>   **启动加载**（Boot loading）模式：简称 “ 自主 ”模式，也就是Boot Loader从目标机上的某个存储设备上将操作系统加载到RAM中运行，整个过程不需要用户的介入。这种模式是Boot Loader的正常工作模式。
>
>   **下载**（Down loading）模式：在这种模式下目标机上的Boot Loader将通过 **串口**连接 或 **网络**连接 等通信手段 从主机下载文件。从主机下载的文件通常首先被Boot Loader保存到目标机的**RAM**中 然后再被Boot Loader写到目标机上的**存储设备**中。
>
>   
>
>   BootLoader 的启动过程 :
>
>   分为**单阶段**（Single-Stage）和 **多阶段**（Multi-Stage）两种。
>
>   通常多阶段的Boot Loader 具有更复杂的功能，更好的可移植性。在存储设备上启动的Boot Loader 大多采用两阶段，即启动过程可以分为 stage1 和 stage2：stage1完成初始化硬件，为stage2准备好内存空间，并将stage2复制到内存中，并设置好堆栈，然后跳转到stage2中



4、给定一个整形变量 lcr, 写两段代码,  第一个置位 lcr 的bit3,  第二个清除 lcr 的bit3。

```c
lcr |= (1 << 3)		//置位
lcr &= ~(1 << 3)	//清位
```

